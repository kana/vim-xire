Testing xire-basics ...                                          Testing xire-basics ===========================================================
<convert-identifier-conventions>-----------------------------------------------
test It should convert properly., expects ("foo_bar_baz" "x_to_y" "set_x" "set_p" "$*@%") ==> ok
<define-binary-operator>-------------------------------------------------------
test It should define a binary operator in the current context., expects "(0 <> 1)" ==> ok
test It should define a binary operator, available only in an expression., expects #<<error>> ==> ok
test It should raise error if the number of operands is less than 2., expects #<<error>> ==> ok
test It should raise error if the number of operands is greater than 2., expects #<<error>> ==> ok
<define-nary-operator>---------------------------------------------------------
test It should define an nary operator in the current context., expects ("(0 <> 1)" "(2 <> 3)" "(4 <> 5 <> 6 <> 7)") ==> ok
test It should define an nary operator, available only in an expression., expects #<<error>> ==> ok
test It should define an N-ary operator, where 2 <= N. (success), expects ("(2 <> 3)" "(4 <> 5 <> 6 <> 7)") ==> ok
test It should define an N-ary operator, where 2 <= N. (failure), expects #<<error>> ==> ok
<define-xire-expression>-------------------------------------------------------
test It should define a xire expression in the current environment., expects (("style" a AAA) ("style" a AAA b BBB) ("style" a AAA rest (BBB CCC))) ==> ok
test It should define a macro which raises error in non-expression context., expects #<<error>> ==> ok
test It should accept the name of a context, expects ("result" #t) ==> ok
<define-xire-function>---------------------------------------------------------
test It should define a xire function in the current environment., expects ("(f03())" "(f03(1))" "(f03(1,\"2\"))" "(f03(1,\"2\",'3'))") ==> ok
test It should raise error for non-expression context., expects #<<error>> ==> ok
test It should raise error for less arguments., expects #<<error>> ==> ok
test It should raise error for more arguments., expects #<<error>> ==> ok
test It should take at least 1 argument., expects #<<error>> ==> ok
test It should take 1 or more arguments., expects ("(f(1))" "(f(1,2))" "(f(1,2,3))") ==> ok
<define-xire-macro>------------------------------------------------------------
test It should define a xire macro in the current environment., expects (#f (< (original-form) = context >)) ==> ok
<define-xire-statement>--------------------------------------------------------
test It should define a xire statement in the current environment., expects (("style" a AAA) ("style" a AAA b BBB) ("style" a AAA rest (BBB CCC))) ==> ok
test It should define a xire macro in statement scope., expects (#t #f) ==> ok
test It should accept the name of a context, expects ("result" #t) ==> ok
test It should define a macro for simple statement such :break., expects (("break!" "\n") ("continue" "\n") ("noel" "\n") ("bang" "\n") ("bang!" "\n")) ==> ok
<main>-------------------------------------------------------------------------
test It should read/write the standard input/output., expects "return (x ? y : z)\n" ==> ok
<x->vim-script-notation>-------------------------------------------------------
test It should convert #f into corresponding value., expects 0 ==> ok
test It should convert #t into corresponding value., expects 1 ==> ok
test It should convert 32 bit signed numbers properly., expects ("0" "123" "-456" "789" "2147483647" "-2147483648") ==> ok
test It should fail to convert numbers beyond 32 bit signed ones (+)., expects #<<error>> ==> ok
test It should fail to convert numbers beyond 32 bit signed ones (-)., expects #<<error>> ==> ok
test It should fail to convert numbers which is not integer., expects #<<error>> ==> ok
test It should convert C-friendly symbols properly., expects ("bufnr" "synIDattr" "has_key") ==> ok
test It should convert also non-C-friendly symbols properly., expects ("predicate_p" "mutate_x" "x_to_y") ==> ok
test It should convert strinigs without special characters., expects ("\"long long time ago\"" "\"we are the one\"") ==> ok
test It should convert strinigs with special characters properly., expects ("\"\\\\\\\"\\f\\n\\r\\t\"" "\"\\x01\"" "\"\\n\\n\"" "\"foobar\"") ==> ok
test It should raise error if an invalid object is given., expects #<<error>> ==> ok
test It should return #f for an invalid object if requested so., expects #f ==> ok
test It should convert regular expressions properly., expects ("''" "'/'" "'\\\\'" "''''" "'foo bar baz'" "'foo/bar\\\\baz'" "'^Angel \\zs\\S\\+\\ze$'") ==> ok
<xire-compile>-----------------------------------------------------------------
test It should raise error for a malformed script: (), expects #<<error>> ==> ok
test It should raise error for a malformed script: (lambda () #f), expects #<<error>> ==> ok
test It should raise error for a malformed script: (no-such-macro), expects #<<error>> ==> ok
test It should raise error for a malformed script: (macro invlaid argument), expects #<<error>> ==> ok
test It should succeed to compile a valid script., expects ("\"" "I am a comment!") ==> ok
test It should succeed to compile a valid expression., expects ("123" "\"string\"" "symbol") ==> ok
test It should raise error to compile an expression in invalid context., expects #<<error>> ==> ok
test It should return stuff which is alredy compiled as is., expects #t ==> ok
test It should repeat macro expansion until given form cannot be expanded., expects ("result" "B" "A") ==> ok
test It should succeed to compile a form that seems to be a function call., expects "(foo(bar,baz))" ==> ok
<xire-compile-expression>------------------------------------------------------
test It should succeed to compile a valid form with an expression context., expects ("123" "\"string\"" "symbol") ==> ok
test It should use an expression context derived from a given context., expects ("123" "\"string\"" "symbol") ==> ok
test It should treat unknown expression macro as a function call., expects "(comment(\"I am a comment!\"))" ==> ok
<xire-compile-forms>-----------------------------------------------------------
test It should succeed to compile a list of valid expressions., expects ("123" "\"string\"" "symbol") ==> ok
test It should succeed to compile a list of valid statements., expects (("\"" "foo") ("\"" "bar") ("\"" "baz")) ==> ok
test It should raise error for invalid context - expressions in statement., expects #<<error>> ==> ok
test It should treat as a function call - statements in expression., expects ("\"foo\"" "(comment(\"bar\"))" "\"baz\"") ==> ok
<xire-context related stuffs>--------------------------------------------------
test <xire-context> should be available., expects #<class <xire-context>> ==> ok
test make-toplevel-context should make a proper instance., expects #<class <xire-context>> ==> ok
test make-statement-context should make a proper instance., expects #<class <xire-context>> ==> ok
test make-expression-context should make a proper instance., expects #<class <xire-context>> ==> ok
test toplevel-context?, expects (#t #f #f) ==> ok
test statement-context?, expects (#t #t #f) ==> ok
test expression-context?, expects (#f #f #t) ==> ok
test ensure-statement-context should succeed for a top-level context., expects #t ==> ok
test ensure-statement-context should succeed for a statement context., expects #t ==> ok
test ensure-statement-context should fail for an expression context., expects #<<error>> ==> ok
test ensure-expression-context should fail for a top-level context., expects #<<error>> ==> ok
test ensure-expression-context should fail for a statement context., expects #<<error>> ==> ok
test ensure-expression-context should succeed for an expression context., expects #t ==> ok
<xire-environment>-------------------------------------------------------------
test It should exist., expects #t ==> ok
test It should have some entries in its macro table by default., expects (#t #t) ==> ok
test It should be a parameter., expects (overridden <xire-environment>) ==> ok
<xire-environment-copy>--------------------------------------------------------
test It should copy the current environment, expects ((#t #t) (#f #t) ((a) (a b))) ==> ok
test It should copy a given environment, expects ((#t #f #f) (#f #t #t) (#f #f #t) ((a) (b) (b c))) ==> ok
<xire-lookup-macro>------------------------------------------------------------
test It should return #f if there is no macro with the given name., expects #f ==> ok
test It should return the expander of a registered macro., expects (expanded-form (original-form)) ==> ok
test It should look up macro from a given environment., expects ((default-environment #f given-environment #f) (default-environment #f given-environment #t)) ==> ok
test It should look up a macro for a specific context., expects ((#t #f) (#f #t) (#f #t)) ==> ok
test It should return different macros for different contexts., expects ((#t #f) (#f #t) (#f #t)) ==> ok
<xire-register-macro!>---------------------------------------------------------
test It should register a macro into the current environment., expects 1 ==> ok
test It should register a macro into a given environment., expects ((default-environment 0 given-environment 0) (default-environment 0 given-environment 1)) ==> ok
<xire-translate>---------------------------------------------------------------
test It should raise error for a malformed script: (), expects #<<error>> ==> ok
test It should raise error for a malformed script: 'invalid-expression, expects #<<error>> ==> ok
test It should raise error for a malformed script: (no-such-macro), expects #<<error>> ==> ok
test It should raise error for a malformed script: (macro invlaid argument), expects #<<error>> ==> ok
test It should succeed to compile a valid script: (macro vlaid argument), expects "\"valid argument" ==> ok
test It should succeed to compile the empty script., expects "" ==> ok
passed.
passed.
