; Test: xire-basics  {{{1

(use gauche.test)
(test-start "xire-basics")
(load "./bin/xirec")
(set! main #f)

(define (hash-table-sorted-keys ht)
  (sort-by (hash-table-keys ht) x->string))

(define (compile-as-string form context)
  (tree->string (xire-compile form context)))




(test-section "convert-identifier-conventions")  ;{{{1

(test* "It should convert properly."
       '("foo_bar_baz"
         "x_to_y"
         "set_x"
         "set_p"
         "$*@%")
       (map convert-identifier-conventions
            '("foo-bar-baz"
              "x->y"
              "set!"
              "set?"
              "$*@%")))




(test-section "define-binary-operator")  ;{{{1

(test* "It should define a binary operator in the current context."
       "(0 <> 1)"
       (parameterize ([xire-environment (make <xire-environment>)])
         (define context (make-expression-context))
         (define-binary-operator == "<>")
         (compile-as-string '(== 0 1) context)))

(test* "It should define a binary operator, available only in an expression."
       (test-error <error>)
       (parameterize ([xire-environment (make <xire-environment>)])
         (define context (make-statement-context))
         (define-binary-operator == "<>")
         (compile-as-string '(== 0 1) context)))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (parameterize ([xire-environment (make <xire-environment>)])
         (define context (make-expression-context))
         (define-binary-operator == "<>")
         (compile-as-string '(== 0) context)))

(test* "It should raise error if the number of operands is greater than 2."
       (test-error <error>)
       (parameterize ([xire-environment (make <xire-environment>)])
         (define context (make-expression-context))
         (define-binary-operator == "<>")
         (compile-as-string '(== 0 1 2) context)))




(test-section "define-nary-operator")  ;{{{1

(test* "It should define an nary operator in the current context."
       '("(0 <> 1)"
         "(2 <> 3)"
         "(4 <> 5 <> 6 <> 7)")
       (parameterize ([xire-environment (make <xire-environment>)])
         (define context (make-expression-context))
         (define-nary-operator + "<>" 0)
         (list
           (compile-as-string '(+ 1) context)
           (compile-as-string '(+ 2 3) context)
           (compile-as-string '(+ 4 5 6 7) context))))

(test* "It should define an nary operator, available only in an expression."
       (test-error <error>)
       (parameterize ([xire-environment (make <xire-environment>)])
         (define context (make-statement-context))
         (define-nary-operator + "<>" 0)
         (xire-compile '(+ 1) context)))

(test* "It should define an N-ary operator, where 2 <= N. (success)"
       '("(2 <> 3)"
         "(4 <> 5 <> 6 <> 7)")
       (parameterize ([xire-environment (make <xire-environment>)])
         (define context (make-expression-context))
         (define-nary-operator + "<>")
         (list
           (compile-as-string '(+ 2 3) context)
           (compile-as-string '(+ 4 5 6 7) context))))

(test* "It should define an N-ary operator, where 2 <= N. (failure)"
       (test-error <error>)
       (parameterize ([xire-environment (make <xire-environment>)])
         (define context (make-expression-context))
         (define-nary-operator + "<>")
         (xire-compile '(+ 1) context)))




(test-section "define-xire-expression")  ;{{{1

(test* "It should define a xire expression in the current environment."
       '((style a AAA)
         (style a AAA b BBB)
         (style a AAA rest (BBB CCC)))
       (parameterize ([xire-environment (make <xire-environment>)])
         (define context (make-expression-context))
         (define-xire-expression my-expression
           [(a)
            `(style a ,a)]
           [(a b)
            `(style a ,a b ,b)]
           [(a . rest)
            `(style a ,a rest ,rest)])
         (list
           (xire-compile '(my-expression AAA) context)
           (xire-compile '(my-expression AAA BBB) context)
           (xire-compile '(my-expression AAA BBB CCC) context))))

(test* "It should define a macro which raises error in non-expression context."
       (test-error <error>)
       (parameterize ([xire-environment (make <xire-environment>)])
         (define context (make-statement-context))
         (define-xire-expression my-expression
           [(a . rest)
            `(style a ,a rest ,rest)])
         (xire-compile '(my-expression AAA BBB CCC) context)))

(test* "It should accept the name of a context"
       #t
       (parameterize ([xire-environment (make <xire-environment>)])
         (define outer-context (make-expression-context))
         (define-xire-expression my-expression inner-context
           [()
            (eq? inner-context outer-context)])
         (let1 another-context outer-context
           (xire-compile '(my-expression) another-context))))




(test-section "define-xire-function")  ;{{{1

(parameterize ([xire-environment (make <xire-environment>)])
  (define context (make-expression-context))
  (define-xire-function f03 0 3)
  (define-xire-function f11 1 1)
  (test* "It should define a xire function in the current environment."
         '("(f03())"
           "(f03(1))"
           "(f03(1,\"2\"))"
           "(f03(1,\"2\",'3'))")
         (map (cut compile-as-string <> context)
              '((f03)
                (f03 1)
                (f03 1 "2")
                (f03 1 "2" #/3/))))
  (test* "It should raise error for non-expression context."
         (test-error <error>)
         (compile-as-string '(f03) (make-statement-context)))
  (test* "It should raise error for less arguments."
         (test-error <error>)
         (compile-as-string '(f11) context))
  (test* "It should raise error for more arguments."
         (test-error <error>)
         (compile-as-string '(f11 1 2) context)))

(parameterize ([xire-environment (make <xire-environment>)])
  (define context (make-expression-context))
  (define-xire-function f 1 #f)
  (test* "It should take at least 1 argument."
         (test-error <error>)
         (compile-as-string '(f) context))
  (test* "It should take 1 or more arguments."
         '("(f(1))"
           "(f(1,2))"
           "(f(1,2,3))")
         (map (cut compile-as-string <> context)
              '((f 1)
                (f 1 2)
                (f 1 2 3)))))




(test-section "define-xire-macro")  ;{{{1

(test* "It should define a xire macro in the current environment."
       '(#f (< (original-form) = context >))
       (parameterize ([xire-environment (make <xire-environment>)])
         (let* ([context (make-toplevel-context)]
                [get-values
                  (lambda ()
                    (let1 expander (xire-lookup-macro 'amane context)
                      (and expander (expander '(original-form) 'context))))]
                [before-values (get-values)])
           (define-xire-macro :statement (amane form context)
             (list '< form '= context '>))
           (list before-values (get-values)))))




(test-section "define-xire-statement")  ;{{{1

(test* "It should define a xire statement in the current environment."
       '((style a AAA)
         (style a AAA b BBB)
         (style a AAA rest (BBB CCC)))
       (parameterize ([xire-environment (make <xire-environment>)])
         (define context (make-statement-context))
         (define-xire-statement my-statement
           [(a)
            `(style a ,a)]
           [(a b)
            `(style a ,a b ,b)]
           [(a . rest)
            `(style a ,a rest ,rest)])
         (list
           (xire-compile '(my-statement AAA) context)
           (xire-compile '(my-statement AAA BBB) context)
           (xire-compile '(my-statement AAA BBB CCC) context))))

(test* "It should define a macro which raises error for non-statement context."
       (test-error <error>)
       (parameterize ([xire-environment (make <xire-environment>)])
         (define context (make-expression-context))
         (define-xire-statement my-statement
           [(a . rest)
            `(style a ,a rest ,rest)])
         (xire-compile '(my-statement AAA BBB CCC) context)))

(test* "It should accept the name of a context"
       #t
       (parameterize ([xire-environment (make <xire-environment>)])
         (define outer-context (make-statement-context))
         (define-xire-statement my-statement inner-context
           [()
            (eq? inner-context outer-context)])
         (let1 another-context outer-context
           (xire-compile '(my-statement) another-context))))

(test* "It should define a macro for simple statement such :break."
       '(("break!" "\n")
         ("continue!" "\n")
         ("noel" "\n"))
       (parameterize ([xire-environment (make <xire-environment>)])
         (define context (make-statement-context))
         (define-xire-statement break "break!")
         (define-xire-statement continue "continue!")
         (define-xire-statement wreathlit "noel")
         (map (cut xire-compile <> context)
              '((break)
                (continue)
                (wreathlit)))))




(test-section "x->vim-script-notation")  ;{{{1

(test* "It should convert 32 bit signed numbers properly."
       '("0" "123" "-456" "789" "2147483647" "-2147483648")
       (map x->vim-script-notation
            (list 0
                  123
                  -456
                  (exact->inexact 789)
                  (- (ash 1 31) 1)
                  (ash -1 31))))
(test* "It should fail to convert numbers beyond 32 bit signed ones (+)."
       (test-error <error>)
       (x->vim-script-notation (ash 1 31)))
(test* "It should fail to convert numbers beyond 32 bit signed ones (-)."
       (test-error <error>)
       (x->vim-script-notation (- (ash -1 31) 1)))
(test* "It should fail to convert numbers which is not integer."
       (test-error <error>)
       (x->vim-script-notation 1/2))

(test* "It should convert C-friendly symbols properly."
       '("bufnr" "synIDattr" "has_key")
       (map x->vim-script-notation
            '(bufnr synIDattr has_key)))

(test* "It should convert also non-C-friendly symbols properly."
       '("predicate_p" "mutate_x" "x_to_y")
       (map x->vim-script-notation
            '(predicate? mutate! x->y)))

;(test* "It should fail to convert symbols with strange characters."
;       (test-error <error>)
;       (x->vim-script-notation '*>_<*))

(test* "It should convert strinigs without special characters."
       '("\"long long time ago\"" "\"we are the one\"")
       (map x->vim-script-notation
            '("long long time ago" "we are the one")))

(test* "It should convert strinigs with special characters properly."
       '("\"\\\\\\\"\\f\\n\\r\\t\""
         "\"\\x01\""
         "\"\\n\\n\""
         ; "\"\\u3042\""  ; FIXME: It's not written with \uNNNN.
         "\"foobar\"")
       (map x->vim-script-notation
            '("\\\"\f\n\r\t"
              "\x01"
              "\x0A\x0a"
              ; "\u3042"  ; "A" in Japanese hiragana.
              "foo\
               bar")))

(test* "It should raise error if an invalid object is given."
       (test-error <error>)
       (x->vim-script-notation '()))

(test* "It should return #f for an invalid object if requested so."
       #f
       (x->vim-script-notation '() #f))

(test* "It should convert regular expressions properly."
       '("''"
         "'/'"
         "'\\\\'"
         "''''"
         "'foo bar baz'"
         "'foo/bar\\\\baz'"
         "'^Angel \\zs\\S\\+\\ze$'")
       (map x->vim-script-notation
            '(#//
              #/\//
              #/\\/
              #/'/
              #/foo bar baz/
              #/foo\/bar\\baz/
              #/^Angel \zs\S\+\ze$/)))




(test-section "xire-compile")  ;{{{1

(test* "It should raise error for a malformed script: ()"
       (test-error <error>)
       (parameterize ([xire-environment (make <xire-environment>)])
         (xire-compile '() (make-toplevel-context))))

(test* "It should raise error for a malformed script: (lambda () #f)"
       (test-error <error>)
       (parameterize ([xire-environment (make <xire-environment>)])
         (xire-compile (lambda () #f) (make-toplevel-context))))

(test* "It should raise error for a malformed script: (\"already compiled\")"
       (test-error <error>)
       (parameterize ([xire-environment (make <xire-environment>)])
         (xire-compile '("already compiled") (make-toplevel-context))))

(test* "It should raise error for a malformed script: (no-such-macro)"
       (test-error <error>)
       (parameterize ([xire-environment (make <xire-environment>)])
         (xire-compile '(no-such-macro) (make-toplevel-context))))

(test* "It should raise error for a malformed script: (macro invlaid argument)"
       (test-error <error>)
       (parameterize ([xire-environment (make <xire-environment>)])
         (define-xire-macro :statement (comment form context)
           (match-let1 (_ comment-string) form
             `("\"" ,comment-string)))
         (xire-compile '(comment "wrong" "argument") (make-toplevel-context))))

(test* "It should succeed to compile a valid script."
       '("\"" "I am a comment!")
       (parameterize ([xire-environment (make <xire-environment>)])
         (define-xire-macro :statement (comment form context)
           (match-let1 (_ comment-string) form
             `("\"" ,comment-string)))
         (xire-compile '(comment "I am a comment!") (make-toplevel-context))))

(test* "It should succeed to compile a valid expression."
       '("123" "\"string\"" "symbol")
       (parameterize ([xire-environment (make <xire-environment>)])
         (let1 context (make-expression-context)
           (map (cut xire-compile <> context)
                '(123 "string" symbol)))))

(test* "It should raise error to compile an expression in invalid context."
       (test-error <error>)
       (parameterize ([xire-environment (make <xire-environment>)])
         (let1 wrong-context (make-statement-context (make-toplevel-context))
           (xire-compile 123 wrong-context))))




(test-section "xire-context related stuffs")  ;{{{1

(test* "<xire-context> should be available."
       <xire-context>
       (class-of (make <xire-context>)))

(test* "make-toplevel-context should make a proper instance."
       (list <xire-context> 'statement)
       (let1 context (make-toplevel-context)
         (list (class-of context)
               (ref context 'type))))
(test* "make-statement-context should make a proper instance."
       (list <xire-context> 'statement)
       (let1 context (make-statement-context)
         (list (class-of context)
               (ref context 'type))))
(test* "make-expression-context should make a proper instance."
       (list <xire-context> 'expression)
       (let1 context (make-expression-context)
         (list (class-of context)
               (ref context 'type))))

(test* "toplevel-context?"
       '(#t #f #f)
       (map toplevel-context?
            (list (make-toplevel-context)
                  (make-statement-context)
                  (make-expression-context))))
(test* "statement-context?"
       '(#t #t #f)
       (map statement-context?
            (list (make-toplevel-context)
                  (make-statement-context)
                  (make-expression-context))))
(test* "expression-context?"
       '(#f #f #t)
       (map expression-context?
            (list (make-toplevel-context)
                  (make-statement-context)
                  (make-expression-context))))

(test* "ensure-statement-context should succeed for a top-level context."
       #t
       (begin
         (ensure-statement-context
           '(form)
           (make-toplevel-context))
         #t))
(test* "ensure-statement-context should succeed for a statement context."
       #t
       (begin
         (ensure-statement-context
           '(form)
           (make-statement-context))
         #t))
(test* "ensure-statement-context should fail for an expression context."
       (test-error <error>)
       (begin
         (ensure-statement-context
           '(form)
           (make-expression-context))
         #t))

(test* "ensure-expression-context should fail for a top-level context."
       (test-error <error>)
       (begin
         (ensure-expression-context
           '(form)
           (make-toplevel-context))
         #t))
(test* "ensure-expression-context should fail for a statement context."
       (test-error <error>)
       (begin
         (ensure-expression-context
           '(form)
           (make-statement-context))
         #t))
(test* "ensure-expression-context should succeed for an expression context."
       #t
       (begin
         (ensure-expression-context
           '(form)
           (make-expression-context))
         #t))




(test-section "xire-environment")  ;{{{1

(test* "It should exist."
       #t
       (is-a? (xire-environment) <xire-environment>))

(test* "It should have some entries in its macro table by default."
       #t
       (<= 0 (hash-table-num-entries (ref (xire-environment) 'macros))))

(test* "It should be a parameter."
       '(overridden <xire-environment>)
       (list (parameterize ([xire-environment 'overridden])
                           (xire-environment))
             (class-name (class-of (xire-environment)))))




(test-section "xire-environment-copy")  ;{{{1

(test* "It should copy the current environment"
       '((#t #t)
         (#f #t)
         ((a) (a b)))
       (parameterize ([xire-environment (make <xire-environment>)])
         (xire-register-macro! 'a
                               (lambda (form) 'a)
                               :statement)
         (let ([context (make-toplevel-context)]
               [environment-copied (xire-environment-copy)])
           (xire-register-macro! 'b
                                 (lambda (form) 'c)
                                 :statement
                                 environment-copied)
           `((,(boolean (xire-lookup-macro 'a context (xire-environment)))
              ,(boolean (xire-lookup-macro 'a context environment-copied)))
             (,(boolean (xire-lookup-macro 'b context (xire-environment)))
              ,(boolean (xire-lookup-macro 'b context environment-copied)))
             (,(hash-table-sorted-keys (ref (xire-environment) 'macros))
              ,(hash-table-sorted-keys (ref environment-copied 'macros)))))))

(test* "It should copy a given environment"
       '((#t #f #f)
         (#f #t #t)
         (#f #f #t)
         ((a) (b) (b c)))
       (parameterize ([xire-environment (make <xire-environment>)])
         (xire-register-macro! 'a
                               (lambda (form) 'a)
                               :statement)
         (let* ([context (make-toplevel-context)]
                [environment-original
                  (let1 environment (make <xire-environment>)
                    (xire-register-macro! 'b
                                          (lambda (form) 'b)
                                          :statement
                                          environment)
                    environment)]
                [environment-copied
                  (let1
                    environment (xire-environment-copy environment-original)
                    (xire-register-macro! 'c
                                          (lambda (form) 'c)
                                          :statement
                                          environment)
                    environment)])
           `((,(boolean (xire-lookup-macro 'a context (xire-environment)))
              ,(boolean (xire-lookup-macro 'a context environment-original))
              ,(boolean (xire-lookup-macro 'a context environment-copied)))
             (,(boolean (xire-lookup-macro 'b context (xire-environment)))
              ,(boolean (xire-lookup-macro 'b context environment-original))
              ,(boolean (xire-lookup-macro 'b context environment-copied)))
             (,(boolean (xire-lookup-macro 'c context (xire-environment)))
              ,(boolean (xire-lookup-macro 'c context environment-original))
              ,(boolean (xire-lookup-macro 'c context environment-copied)))
             (,(hash-table-sorted-keys (ref (xire-environment) 'macros))
              ,(hash-table-sorted-keys (ref environment-original 'macros))
              ,(hash-table-sorted-keys (ref environment-copied 'macros)))))))




(test-section "xire-lookup-macro")  ;{{{1

(test* "It should return #f if there is no macro with the given name."
       #f
       (parameterize ([xire-environment (make <xire-environment>)])
         (xire-lookup-macro 'there-is-no-such-macro (make-toplevel-context))))

(test* "It should return the expander of a registered macro."
       '(expanded-form (original-form))
       (parameterize ([xire-environment (make <xire-environment>)])
         (define (expander form)
           (list 'expanded-form form))
         (xire-register-macro! 'sasara expander :statement)
         ((xire-lookup-macro 'sasara (make-toplevel-context))
          '(original-form))))

(test* "It should look up macro from a given environment."
       '((default-environment #f given-environment #f)
         (default-environment #f given-environment #t))
       (parameterize ([xire-environment (make <xire-environment>)])
         (let* ([context (make-toplevel-context)]
                [environment (make <xire-environment>)]
                [expand
                  (lambda (expander)
                    (and expander (expander '(original-form))))]
                [get-values
                  (lambda ()
                    (list 'default-environment
                          (expand (xire-lookup-macro 'mashiro
                                                     context
                                                     (xire-environment)))
                          'given-environment
                          (expand (xire-lookup-macro 'mashiro
                                                     context
                                                     environment))))]
                [before-values (get-values)])
           (xire-register-macro! 'mashiro
                                 (lambda (form . args) #t)
                                 :statement
                                 environment)
           (list before-values (get-values)))))




(test-section "xire-register-macro!")  ;{{{1

(test* "It should register a macro into the current environment."
       1
       (parameterize ([xire-environment (make <xire-environment>)])
         (xire-register-macro! 'arisa
                               (lambda (form . args) 'arisa)
                               :statement)
         (hash-table-num-entries (ref (xire-environment) 'macros))))

(test* "It should register a macro into a given environment."
       '((default-environment 0 given-environment 0)
         (default-environment 0 given-environment 1))
       (parameterize ([xire-environment (make <xire-environment>)])
         (let* ([environment (make <xire-environment>)]
                [get-values
                  (lambda ()
                    (list 'default-environment
                          (hash-table-num-entries
                            (ref (xire-environment) 'macros))
                          'given-environment
                          (hash-table-num-entries
                            (ref environment 'macros))))]
                [before-values (get-values)])
           (xire-register-macro! 'sasara
                                 (lambda (form . args) 'sasara)
                                 :statement
                                 environment)
           (list before-values (get-values)))))




(test-section "xire-translate")  ;{{{1

(test* "It should raise error for a malformed script: ()"
       (test-error <error>)
       (call-with-string-io "()"
         (cut xire-translate <> <> :environment (make <xire-environment>))))

(test* "It should raise error for a malformed script: 'invalid-expression"
       (test-error <error>)
       (call-with-string-io "invalid-expression"
         (cut xire-translate <> <> :environment (make <xire-environment>))))

(test* "It should raise error for a malformed script: (no-such-macro)"
       (test-error <error>)
       (parameterize ([xire-environment (make <xire-environment>)])
         (call-with-string-io "(no-such-macro)"
           (cut xire-translate <> <>))))

(test* "It should raise error for a malformed script: (macro invlaid argument)"
       (test-error <error>)
       (parameterize ([xire-environment (make <xire-environment>)])
         (define-xire-macro :statement (comment form context)
           (match-let1 (_ comment-string) form
             `("\"" ,comment-string)))
         (call-with-string-io "(comment \"wrong\" \"argument\")"
           (cut xire-translate <> <>))))

(test* "It should succeed to compile a valid script: (macro vlaid argument)"
       "\"valid argument"
       (parameterize ([xire-environment (make <xire-environment>)])
         (define-xire-macro :statement (comment form context)
           (match-let1 (_ comment-string) form
             `("\"" ,comment-string)))
         (call-with-string-io "(comment \"valid argument\")"
           (cut xire-translate <> <>))))

(test* "It should succeed to compile the empty script."
       ""
       (call-with-string-io ""
         (cut xire-translate <> <> :environment (make <xire-environment>))))




;(test-section "template")  ;{{{1

;(test* "title"
;       expected-value
;       test-expression)




(test-end)  ;{{{1




; __END__
; vim: filetype=scheme foldmethod=marker
