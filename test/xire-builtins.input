; Test: xire-builtins  {{{1

(use gauche.test)
(test-start "xire-builtins")
(load "./bin/xirec")
(set! main #f)

(define (compile-expression expression)
  (define context (make-expression-context (make <xire-context>)))
  (tree->string (xire-compile expression context)))




; Expression  ;{{{1
(test-section "(?: expression then-part else-part)")  ;{{{2

(test* "It should be compiled properly."
       "(0 ? 1 : 2)"
       (compile-expression '(?: 0 1 2)))

(test* "It should raise error if the number of operands is less than 3."
       (test-error <error>)
       (compile-expression '(?: 0 1)))

(test* "It should raise error if the number of operands is greater than 3."
       (test-error <error>)
       (compile-expression '(?: 0 1 2 3)))




(test-section "(or expression ..2)")  ;{{{2

(test* "It should be compiled properly."
       '("(1 || 2)"
         "(3 || 4 || 5)")
       (list (compile-expression '(or 1 2))
             (compile-expression '(or 3 4 5))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(or 1)))




(test-section "(and expression ..2)")  ;{{{2

(test* "It should be compiled properly."
       '("(1 && 2)"
         "(3 && 4 && 5)")
       (list (compile-expression '(and 1 2))
             (compile-expression '(and 3 4 5))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(and 1)))




(test-section "comparison operators")  ;{{{2

(test* "It should be available."
       '("(1 != 2)"
         "(1 !=# 2)"
         "(1 !=? 2)"
         "(1 !~ 2)"
         "(1 !~# 2)"
         "(1 !~? 2)"
         "(1 < 2)"
         "(1 <# 2)"
         "(1 <= 2)"
         "(1 <=# 2)"
         "(1 <=? 2)"
         "(1 <? 2)"
         "(1 == 2)"
         "(1 ==# 2)"
         "(1 ==? 2)"
         "(1 =~ 2)"
         "(1 =~# 2)"
         "(1 =~? 2)"
         "(1 > 2)"
         "(1 ># 2)"
         "(1 >= 2)"
         "(1 >=# 2)"
         "(1 >=? 2)"
         "(1 >? 2)"
         "(1 is 2)"
         "(1 is# 2)"
         "(1 is? 2)"
         "(1 isnot 2)"
         "(1 isnot# 2)"
         "(1 isnot? 2)")
       (map
         (lambda (operator) (compile-expression `(,operator 1 2)))
         '(!=
           !=#
           !=?
           !~
           !~#
           !~?
           <
           <#
           <=
           <=#
           <=?
           <?
           ==
           ==#
           ==?
           =~
           =~#
           =~?
           >
           >#
           >=
           >=#
           >=?
           >?
           is
           is#
           is?
           isnot
           isnot#
           isnot?)))




(test-section "(+ expression ..1)")  ;{{{2

(test* "It should be compiled properly."
       '("(0 + 999)"
         "(1 + 2)"
         "(3 + 4 + 5)")
       (list (compile-expression '(+ 999))
             (compile-expression '(+ 1 2))
             (compile-expression '(+ 3 4 5))))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-expression '(+)))




(test-section "(- expression ..1)")  ;{{{2

(test* "It should be compiled properly."
       '("(0 - 999)"
         "(1 - 2)"
         "(3 - 4 - 5)")
       (list (compile-expression '(- 999))
             (compile-expression '(- 1 2))
             (compile-expression '(- 3 4 5))))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-expression '(-)))




(test-section "(.. expression ..2)")  ;{{{2

(test* "It should be compiled properly."
       '("(\"1\" . \"2\")"
         "(\"3\" . \"4\" . \"5\")")
       (list (compile-expression '(.. "1" "2"))
             (compile-expression '(.. "3" "4" "5"))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(.. "0")))




(test-section "(* expression ..2)")  ;{{{2

(test* "It should be compiled properly."
       '("(1 * 2)"
         "(3 * 4 * 5)")
       (list (compile-expression '(* 1 2))
             (compile-expression '(* 3 4 5))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(* 999)))




(test-section "(/ expression ..2)")  ;{{{2

(test* "It should be compiled properly."
       '("(1 / 2)"
         "(3 / 4 / 5)")
       (list (compile-expression '(/ 1 2))
             (compile-expression '(/ 3 4 5))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(/ 999)))




(test-section "(% expression ..2)")  ;{{{2

(test* "It should be compiled properly."
       '("(1 % 2)"
         "(3 % 4 % 5)")
       (list (compile-expression '(% 1 2))
             (compile-expression '(% 3 4 5))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(% 999)))




(test-section "(not expression)")  ;{{{2

(test* "It should be compiled properly."
       "(!0)"
       (compile-expression '(not 0)))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-expression '(not)))

(test* "It should raise error if the number of operands is greater than 1."
       (test-error <error>)
       (compile-expression '(not 0 0)))




(test-section "(ref array index)")  ;{{{2

(test* "It should be compiled properly."
       "((array)[(123)])"
       (compile-expression '(ref array 123)))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(ref)))

(test* "It should raise error if the number of operands is greater than 2."
       (test-error <error>)
       (compile-expression '(ref 1 2 3)))




(test-section "(slice array index1 index2)")  ;{{{2

(test* "It should be compiled properly."
       "((array)[(123):(456)])"
       (compile-expression '(slice array 123 456)))

(test* "It should raise error if the number of operands is less than 3."
       (test-error <error>)
       (compile-expression '(slice 123)))

(test* "It should raise error if the number of operands is greater than 3."
       (test-error <error>)
       (compile-expression '(slice 1 2 3 4)))




(test-section "(-> dictionary member)")  ;{{{2

(test* "It should be compiled properly."
       "((dictionary).member)"
       (compile-expression '(-> dictionary member)))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(-> dictionary)))

(test* "It should raise error if the number of operands is greater than 2."
       (test-error <error>)
       (compile-expression '(-> dictionary member more-member)))




(test-section "(apply function argument ...)")  ;{{{2

(test* "It should be compiled properly."
       '("(function())"
         "(function(1))"
         "(function(1,2))"
         "(function(1,2,3))")
       (list (compile-expression '(apply function))
             (compile-expression '(apply function 1))
             (compile-expression '(apply function 1 2))
             (compile-expression '(apply function 1 2 3))))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-expression '(apply)))




(test-section "(list expression ...)")  ;{{{2

(test* "It should be compiled properly."
       '("[]"
         "[1]"
         "[1,2]"
         "[1,2,3]")
       (list (compile-expression '(list))
             (compile-expression '(list 1))
             (compile-expression '(list 1 2))
             (compile-expression '(list 1 2 3))))




(test-section "comment")  ;{{{1

(test* "It should be available."
       #t
       (boolean (xire-lookup-macro 'comment)))

(test* "It should compile a given form into a Vim-script comment."
       '(("\"" () "\n")
         ("\"" (" " "foo") "\n")
         ("\"" (" " "foo" " " "bar") "\n"))
       (let ([expander (xire-lookup-macro 'comment)]
             [context (make-statement-context (make <xire-context>))])
         (list
           (expander '(comment) context)
           (expander '(comment "foo") context)
           (expander '(comment "foo" "bar") context))))

(test* "It should raise error for invalid arguments"
       (test-error <error>)
       (let1 expander (xire-lookup-macro 'comment)
         (expander '(comment "a" #\b "c")
                   (make-statement-context (make <xire-context>)))))

(test* "It should raise error for non-statement context"
       (test-error <error>)
       (let1 expander (xire-lookup-macro 'comment)
         (expander '(comment "a")
                   (make-expression-context (make <xire-context>)))))




;(test-section "template")  ;{{{1

;(test* "title"
;       expected-value
;       test-expression)




(test-end)  ;{{{1




; __END__
; vim: filetype=scheme foldmethod=marker
