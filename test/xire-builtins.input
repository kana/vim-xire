; Test: xire-builtins  {{{1

(use gauche.test)
(test-start "xire-builtins")
(load "./bin/xirec")
(set! main #f)

(define (compile-expression expression)
  (define context (make-expression-context (make <xire-context>)))
  (tree->string (xire-compile expression context)))

(define (compile-statement statement)
  (define context (make-statement-context (make <xire-context>)))
  (tree->string (xire-compile statement context)))

(define (join . lines)
  (string-join lines "\n" 'suffix))




; Expression  ;{{{1
(test-section "(?: expression then-part else-part)")  ;{{{2

(test* "It should be compiled properly."
       "(0 ? 1 : 2)"
       (compile-expression '(?: 0 1 2)))

(test* "It should raise error if the number of operands is less than 3."
       (test-error <error>)
       (compile-expression '(?: 0 1)))

(test* "It should raise error if the number of operands is greater than 3."
       (test-error <error>)
       (compile-expression '(?: 0 1 2 3)))




(test-section "(or expression ..2)")  ;{{{2

(test* "It should be compiled properly."
       '("(1 || 2)"
         "(3 || 4 || 5)")
       (list (compile-expression '(or 1 2))
             (compile-expression '(or 3 4 5))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(or 1)))




(test-section "(and expression ..2)")  ;{{{2

(test* "It should be compiled properly."
       '("(1 && 2)"
         "(3 && 4 && 5)")
       (list (compile-expression '(and 1 2))
             (compile-expression '(and 3 4 5))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(and 1)))




(test-section "comparison operators")  ;{{{2

(test* "It should be available."
       '("(1 != 2)"
         "(1 !=# 2)"
         "(1 !=? 2)"
         "(1 !~ 2)"
         "(1 !~# 2)"
         "(1 !~? 2)"
         "(1 < 2)"
         "(1 <# 2)"
         "(1 <= 2)"
         "(1 <=# 2)"
         "(1 <=? 2)"
         "(1 <? 2)"
         "(1 == 2)"
         "(1 ==# 2)"
         "(1 ==? 2)"
         "(1 =~ 2)"
         "(1 =~# 2)"
         "(1 =~? 2)"
         "(1 > 2)"
         "(1 ># 2)"
         "(1 >= 2)"
         "(1 >=# 2)"
         "(1 >=? 2)"
         "(1 >? 2)"
         "(1 is 2)"
         "(1 is# 2)"
         "(1 is? 2)"
         "(1 isnot 2)"
         "(1 isnot# 2)"
         "(1 isnot? 2)")
       (map
         (lambda (operator) (compile-expression `(,operator 1 2)))
         '(!=
           !=#
           !=?
           !~
           !~#
           !~?
           <
           <#
           <=
           <=#
           <=?
           <?
           ==
           ==#
           ==?
           =~
           =~#
           =~?
           >
           >#
           >=
           >=#
           >=?
           >?
           is
           is#
           is?
           isnot
           isnot#
           isnot?)))




(test-section "(+ expression ..1)")  ;{{{2

(test* "It should be compiled properly."
       '("(0 + 999)"
         "(1 + 2)"
         "(3 + 4 + 5)")
       (list (compile-expression '(+ 999))
             (compile-expression '(+ 1 2))
             (compile-expression '(+ 3 4 5))))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-expression '(+)))




(test-section "(- expression ..1)")  ;{{{2

(test* "It should be compiled properly."
       '("(0 - 999)"
         "(1 - 2)"
         "(3 - 4 - 5)")
       (list (compile-expression '(- 999))
             (compile-expression '(- 1 2))
             (compile-expression '(- 3 4 5))))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-expression '(-)))




(test-section "(.. expression ..2)")  ;{{{2

(test* "It should be compiled properly."
       '("(\"1\" . \"2\")"
         "(\"3\" . \"4\" . \"5\")")
       (list (compile-expression '(.. "1" "2"))
             (compile-expression '(.. "3" "4" "5"))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(.. "0")))




(test-section "(* expression ..2)")  ;{{{2

(test* "It should be compiled properly."
       '("(1 * 2)"
         "(3 * 4 * 5)")
       (list (compile-expression '(* 1 2))
             (compile-expression '(* 3 4 5))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(* 999)))




(test-section "(/ expression ..2)")  ;{{{2

(test* "It should be compiled properly."
       '("(1 / 2)"
         "(3 / 4 / 5)")
       (list (compile-expression '(/ 1 2))
             (compile-expression '(/ 3 4 5))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(/ 999)))




(test-section "(% expression ..2)")  ;{{{2

(test* "It should be compiled properly."
       '("(1 % 2)"
         "(3 % 4 % 5)")
       (list (compile-expression '(% 1 2))
             (compile-expression '(% 3 4 5))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(% 999)))




(test-section "(not expression)")  ;{{{2

(test* "It should be compiled properly."
       "(!0)"
       (compile-expression '(not 0)))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-expression '(not)))

(test* "It should raise error if the number of operands is greater than 1."
       (test-error <error>)
       (compile-expression '(not 0 0)))




(test-section "(ref array index)")  ;{{{2

(test* "It should be compiled properly."
       "((array)[(123)])"
       (compile-expression '(ref array 123)))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(ref)))

(test* "It should raise error if the number of operands is greater than 2."
       (test-error <error>)
       (compile-expression '(ref 1 2 3)))




(test-section "(slice array index1 index2)")  ;{{{2

(test* "It should be compiled properly."
       "((array)[(123):(456)])"
       (compile-expression '(slice array 123 456)))

(test* "It should raise error if the number of operands is less than 3."
       (test-error <error>)
       (compile-expression '(slice 123)))

(test* "It should raise error if the number of operands is greater than 3."
       (test-error <error>)
       (compile-expression '(slice 1 2 3 4)))




(test-section "(-> dictionary member)")  ;{{{2

(test* "It should be compiled properly."
       "((dictionary).member)"
       (compile-expression '(-> dictionary member)))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(-> dictionary)))

(test* "It should raise error if the number of operands is greater than 2."
       (test-error <error>)
       (compile-expression '(-> dictionary member more-member)))




(test-section "(apply function argument ...)")  ;{{{2

(test* "It should be compiled properly."
       '("(function())"
         "(function(1))"
         "(function(1,2))"
         "(function(1,2,3))")
       (list (compile-expression '(apply function))
             (compile-expression '(apply function 1))
             (compile-expression '(apply function 1 2))
             (compile-expression '(apply function 1 2 3))))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-expression '(apply)))




(test-section "(list expression ...)")  ;{{{2

(test* "It should be compiled properly."
       '("[]"
         "[1]"
         "[1,2]"
         "[1,2,3]")
       (list (compile-expression '(list))
             (compile-expression '(list 1))
             (compile-expression '(list 1 2))
             (compile-expression '(list 1 2 3))))




(test-section "(dict (key value) ...)")  ;{{{2

(test* "It should be compiled properly."
       '("{}"
         "{k1 : v1}"
         "{k1 : v1,k2 : v2}"
         "{k1 : v1,k2 : v2,k3 : v3}")
       (list (compile-expression '(dict))
             (compile-expression '(dict [k1 v1]))
             (compile-expression '(dict [k1 v1] [k2 v2]))
             (compile-expression '(dict [k1 v1] [k2 v2] [k3 v3]))))




(test-section "(& option)")  ;{{{2

(test* "It should be compiled properly."
       '("&option"
         "&l:option"
         "&g:option")
       (list (compile-expression '(& option))
             (compile-expression '(& l:option))
             (compile-expression '(& g:option))))

(test* "It should raise error if the given option name is not a symbol."
       (test-error <error>)
       (compile-expression '(& "string")))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-expression '(&)))

(test* "It should raise error if the number of operands is greater than 1."
       (test-error <error>)
       (compile-expression '(& foo bar)))




(test-section "($ variable)")  ;{{{2

(test* "It should be compiled properly."
       "$variable"
       (compile-expression '($ variable)))

(test* "It should raise error if the given option name is not a symbol."
       (test-error <error>)
       (compile-expression '($ "string")))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-expression '($)))

(test* "It should raise error if the number of operands is greater than 1."
       (test-error <error>)
       (compile-expression '($ foo bar)))




(test-section "(@ register)")  ;{{{2

(test* "It should be compiled properly."
       "@r"
       (compile-expression '(@ r)))

(test* "It should raise error if the given option name is not a symbol."
       (test-error <error>)
       (compile-expression '(@ "string")))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-expression '(@)))

(test* "It should raise error if the number of operands is greater than 1."
       (test-error <error>)
       (compile-expression '(@ foo bar)))




; Control flow  ;{{{1
(test-section "(begin ...)")  ;{{{2

(test* "It should be compiled properly."
       (list (join "echo 1")
             (join "echo 2" "echo 3")
             (join "echo 4" "echo 5" "echo 6"))
       (list (compile-statement '(begin (echo 1)))
             (compile-statement '(begin (echo 2) (echo 3)))
             (compile-statement '(begin (echo 4) (echo 5) (echo 6)))))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-statement '(begin)))




(test-section "(if ...)")  ;{{{2

(test* "It should be compiled properly."
       (list (join "if 1" "echo 2" "endif")
             (join "if 1" "echo 2" "else" "echo 3" "endif"))
       (list (compile-statement '(if 1 (echo 2)))
             (compile-statement '(if 1 (echo 2) (echo 3)))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-statement '(if 1)))

(test* "It should raise error if the number of operands is greater than 3."
       (test-error <error>)
       (compile-statement '(if 1 2 3 4)))




(test-section "(while ...)")  ;{{{2

(test* "It should be compiled properly."
       (list (join "while 1" "echo 2" "endwhile")
             (join "while 1" "echo 2" "echo 3" "endwhile"))
       (list (compile-statement '(while 1 (echo 2)))
             (compile-statement '(while 1 (echo 2) (echo 3)))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-statement '(while 1)))




(test-section "(for ...)")  ;{{{2

(test* "It, 'for i in list', should be compiled properly."
       (list (join "for i in [1,2,3]" "echo i" "endfor")
             (join "for i in [1,2,3]" "echo i" "echo i i" "endfor"))
       (list (compile-statement '(for i (list 1 2 3) (echo i)))
             (compile-statement '(for i (list 1 2 3) (echo i) (echo i i)))))

(test* "It, 'for [i, ...] in list-of-lists', should be compiled properly."
       (list (join "for [i] in [[1],[2]]" "echo i" "endfor")
             (join "for [i,j] in [[1,2],[3,4]]" "echo i" "echo j" "endfor"))
       (list (compile-statement
               '(for (i) (list (list 1) (list 2)) (echo i)))
             (compile-statement
               '(for (i j) (list (list 1 2) (list 3 4)) (echo i) (echo j)))))

(test* "It should raise error if the number of operands is less than 3."
       (test-error <error>)
       (compile-statement '(for i (list 1 2 3))))




(test-section "(break)")  ;{{{2

(test* "It should be compiled properly."
       (join "break")
       (compile-statement '(break)))

(test* "It should raise error if the number of operands is greater than 0."
       (test-error <error>)
       (compile-statement '(break me down)))




(test-section "(continue)")  ;{{{2

(test* "It should be compiled properly."
       (join "continue")
       (compile-statement '(continue)))

(test* "It should raise error if the number of operands is greater than 0."
       (test-error <error>)
       (compile-statement '(continue me down)))




; Other Ex commands  ;{{{1
(test-section "(echo expression ...)")  ;{{{2

(test* "It should be compiled properly."
       '("echo \n"
         "echo 1\n"
         "echo 1 2\n"
         "echo 1 (2 + 3)\n")
       (list (compile-statement '(echo))
             (compile-statement '(echo 1))
             (compile-statement '(echo 1 2))
             (compile-statement '(echo 1 (+ 2 3)))))




(test-section "comment")  ;{{{1

(test* "It should be available."
       #t
       (boolean (xire-lookup-macro 'comment)))

(test* "It should compile a given form into a Vim-script comment."
       '(("\"" () "\n")
         ("\"" (" " "foo") "\n")
         ("\"" (" " "foo" " " "bar") "\n"))
       (let ([expander (xire-lookup-macro 'comment)]
             [context (make-statement-context (make <xire-context>))])
         (list
           (expander '(comment) context)
           (expander '(comment "foo") context)
           (expander '(comment "foo" "bar") context))))

(test* "It should raise error for invalid arguments"
       (test-error <error>)
       (let1 expander (xire-lookup-macro 'comment)
         (expander '(comment "a" #\b "c")
                   (make-statement-context (make <xire-context>)))))

(test* "It should raise error for non-statement context"
       (test-error <error>)
       (let1 expander (xire-lookup-macro 'comment)
         (expander '(comment "a")
                   (make-expression-context (make <xire-context>)))))




;(test-section "template")  ;{{{1

;(test* "title"
;       expected-value
;       test-expression)




(test-end)  ;{{{1




; __END__
; vim: filetype=scheme foldmethod=marker
