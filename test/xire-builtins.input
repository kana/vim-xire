; Test: xire-builtins  {{{1

(use gauche.test)
(test-start "xire-builtins")
(load "./bin/xirec")
(set! main #f)

(define (compile-expression expression)
  (define context (make-expression-context))
  (tree->string (xire-compile expression context)))

(define (compile-statement statement)
  (define context (make-statement-context))
  (tree->string (xire-compile statement context)))

(define (join . lines)
  (string-join lines "\n" 'suffix))




; Primitives  ;{{{1
(test-section "(RAW ...)")  ;{{{2

(test* "It should be compiled properly in statement context."
       '(""
         "\" Apple"
         "banana\ncherry\ndandelion\n")
       (list (compile-statement '(RAW ""))
             (compile-statement '(RAW "" "\"" " " "Apple"))
             (compile-statement '(RAW "banana\n" "cherry\n" "dandelion\n"))))

(test* "It should not be compiled in expression context."
       (test-error <error>)
       (compile-expression '(RAW "")))




(test-section "comment")  ;{{{2

(test* "It should be available."
       #t
       (boolean (xire-lookup-macro 'comment (make-toplevel-context))))

(test* "It should compile a given form into a Vim-script comment."
       '("\"\n"
         "\" foo\n"
         "\" foo bar\n")
       (list (compile-statement '(comment))
             (compile-statement '(comment "foo"))
             (compile-statement '(comment "foo" "bar"))))

(test* "It should raise error for invalid arguments"
       (test-error <error>)
       (compile-statement '(comment "a" #\b "c")))

(test* "It should raise error for non-statement context"
       (test-error <error>)
       (compile-expression '(comment "a")))




; Expression  ;{{{1
(test-section "(?: expression then-part else-part)")  ;{{{2

(test* "It should be compiled properly."
       "(0 ? 1 : 2)"
       (compile-expression '(?: 0 1 2)))

(test* "It should raise error if the number of operands is less than 3."
       (test-error <error>)
       (compile-expression '(?: 0 1)))

(test* "It should raise error if the number of operands is greater than 3."
       (test-error <error>)
       (compile-expression '(?: 0 1 2 3)))




(test-section "(or expression ..2)")  ;{{{2

(test* "It should be compiled properly."
       '("(1 || 2)"
         "(3 || 4 || 5)")
       (list (compile-expression '(or 1 2))
             (compile-expression '(or 3 4 5))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(or 1)))




(test-section "(and expression ..2)")  ;{{{2

(test* "It should be compiled properly."
       '("(1 && 2)"
         "(3 && 4 && 5)")
       (list (compile-expression '(and 1 2))
             (compile-expression '(and 3 4 5))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(and 1)))




(test-section "comparison operators")  ;{{{2

(test* "It should be available."
       '("(1 != 2)"
         "(1 !=# 2)"
         "(1 !=? 2)"
         "(1 !~ 2)"
         "(1 !~# 2)"
         "(1 !~? 2)"
         "(1 < 2)"
         "(1 <# 2)"
         "(1 <= 2)"
         "(1 <=# 2)"
         "(1 <=? 2)"
         "(1 <? 2)"
         "(1 == 2)"
         "(1 ==# 2)"
         "(1 ==? 2)"
         "(1 =~ 2)"
         "(1 =~# 2)"
         "(1 =~? 2)"
         "(1 > 2)"
         "(1 ># 2)"
         "(1 >= 2)"
         "(1 >=# 2)"
         "(1 >=? 2)"
         "(1 >? 2)"
         "(1 is 2)"
         "(1 is# 2)"
         "(1 is? 2)"
         "(1 isnot 2)"
         "(1 isnot# 2)"
         "(1 isnot? 2)")
       (map
         (lambda (operator) (compile-expression `(,operator 1 2)))
         '(!=
           !=#
           !=?
           !~
           !~#
           !~?
           <
           <#
           <=
           <=#
           <=?
           <?
           ==
           ==#
           ==?
           =~
           =~#
           =~?
           >
           >#
           >=
           >=#
           >=?
           >?
           is
           is#
           is?
           isnot
           isnot#
           isnot?)))




(test-section "(+ expression ..1)")  ;{{{2

(test* "It should be compiled properly."
       '("(0 + 999)"
         "(1 + 2)"
         "(3 + 4 + 5)")
       (list (compile-expression '(+ 999))
             (compile-expression '(+ 1 2))
             (compile-expression '(+ 3 4 5))))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-expression '(+)))




(test-section "(- expression ..1)")  ;{{{2

(test* "It should be compiled properly."
       '("(0 - 999)"
         "(1 - 2)"
         "(3 - 4 - 5)")
       (list (compile-expression '(- 999))
             (compile-expression '(- 1 2))
             (compile-expression '(- 3 4 5))))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-expression '(-)))




(test-section "(.. expression ..2)")  ;{{{2

(test* "It should be compiled properly."
       '("(\"1\" . \"2\")"
         "(\"3\" . \"4\" . \"5\")")
       (list (compile-expression '(.. "1" "2"))
             (compile-expression '(.. "3" "4" "5"))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(.. "0")))




(test-section "(* expression ..2)")  ;{{{2

(test* "It should be compiled properly."
       '("(1 * 2)"
         "(3 * 4 * 5)")
       (list (compile-expression '(* 1 2))
             (compile-expression '(* 3 4 5))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(* 999)))




(test-section "(/ expression ..2)")  ;{{{2

(test* "It should be compiled properly."
       '("(1 / 2)"
         "(3 / 4 / 5)")
       (list (compile-expression '(/ 1 2))
             (compile-expression '(/ 3 4 5))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(/ 999)))




(test-section "(% expression ..2)")  ;{{{2

(test* "It should be compiled properly."
       '("(1 % 2)"
         "(3 % 4 % 5)")
       (list (compile-expression '(% 1 2))
             (compile-expression '(% 3 4 5))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(% 999)))




(test-section "(not expression)")  ;{{{2

(test* "It should be compiled properly."
       "(!0)"
       (compile-expression '(not 0)))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-expression '(not)))

(test* "It should raise error if the number of operands is greater than 1."
       (test-error <error>)
       (compile-expression '(not 0 0)))




(test-section "(ref array index)")  ;{{{2

(test* "It should be compiled properly."
       "((array)[(123)])"
       (compile-expression '(ref array 123)))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(ref)))

(test* "It should raise error if the number of operands is greater than 2."
       (test-error <error>)
       (compile-expression '(ref 1 2 3)))




(test-section "(slice array index1 index2)")  ;{{{2

(test* "It should be compiled properly."
       "((array)[(123):(456)])"
       (compile-expression '(slice array 123 456)))

(test* "It should raise error if the number of operands is less than 3."
       (test-error <error>)
       (compile-expression '(slice 123)))

(test* "It should raise error if the number of operands is greater than 3."
       (test-error <error>)
       (compile-expression '(slice 1 2 3 4)))




(test-section "(-> dictionary member)")  ;{{{2

(test* "It should be compiled properly."
       "((dictionary).member)"
       (compile-expression '(-> dictionary member)))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(-> dictionary)))

(test* "It should raise error if the number of operands is greater than 2."
       (test-error <error>)
       (compile-expression '(-> dictionary member more-member)))




(test-section "(apply function argument ...)")  ;{{{2

(test* "It should be compiled properly."
       '("(function())"
         "(function(1))"
         "(function(1,2))"
         "(function(1,2,3))")
       (list (compile-expression '(apply function))
             (compile-expression '(apply function 1))
             (compile-expression '(apply function 1 2))
             (compile-expression '(apply function 1 2 3))))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-expression '(apply)))




(test-section "(list expression ...)")  ;{{{2

(test* "It should be compiled properly."
       '("[]"
         "[1]"
         "[1,2]"
         "[1,2,3]")
       (list (compile-expression '(list))
             (compile-expression '(list 1))
             (compile-expression '(list 1 2))
             (compile-expression '(list 1 2 3))))




(test-section "(dict (key value) ...)")  ;{{{2

(test* "It should be compiled properly."
       '("{}"
         "{k1 : v1}"
         "{k1 : v1,k2 : v2}"
         "{k1 : v1,k2 : v2,k3 : v3}")
       (list (compile-expression '(dict))
             (compile-expression '(dict [k1 v1]))
             (compile-expression '(dict [k1 v1] [k2 v2]))
             (compile-expression '(dict [k1 v1] [k2 v2] [k3 v3]))))




(test-section "(& option)")  ;{{{2

(test* "It should be compiled properly."
       '("&option"
         "&l:option"
         "&g:option")
       (list (compile-expression '(& option))
             (compile-expression '(& l:option))
             (compile-expression '(& g:option))))

(test* "It should raise error if the given option name is not a symbol."
       (test-error <error>)
       (compile-expression '(& "string")))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-expression '(&)))

(test* "It should raise error if the number of operands is greater than 1."
       (test-error <error>)
       (compile-expression '(& foo bar)))




(test-section "($ variable)")  ;{{{2

(test* "It should be compiled properly."
       "$variable"
       (compile-expression '($ variable)))

(test* "It should raise error if the given option name is not a symbol."
       (test-error <error>)
       (compile-expression '($ "string")))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-expression '($)))

(test* "It should raise error if the number of operands is greater than 1."
       (test-error <error>)
       (compile-expression '($ foo bar)))




(test-section "(@ register)")  ;{{{2

(test* "It should be compiled properly."
       "@r"
       (compile-expression '(@ r)))

(test* "It should raise error if the given option name is not a symbol."
       (test-error <error>)
       (compile-expression '(@ "string")))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-expression '(@)))

(test* "It should raise error if the number of operands is greater than 1."
       (test-error <error>)
       (compile-expression '(@ foo bar)))




; Control flow  ;{{{1
(test-section "(begin ...)")  ;{{{2

(test* "It should be compiled properly."
       (list (join "echo 1")
             (join "echo 2" "echo 3")
             (join "echo 4" "echo 5" "echo 6"))
       (list (compile-statement '(begin (echo 1)))
             (compile-statement '(begin (echo 2) (echo 3)))
             (compile-statement '(begin (echo 4) (echo 5) (echo 6)))))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-statement '(begin)))




(test-section "(if ...)")  ;{{{2

(test* "It should be compiled properly."
       (list (join "if 1" "echo 2" "endif")
             (join "if 1" "echo 2" "else" "echo 3" "endif"))
       (list (compile-statement '(if 1 (echo 2)))
             (compile-statement '(if 1 (echo 2) (echo 3)))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-statement '(if 1)))

(test* "It should raise error if the number of operands is greater than 3."
       (test-error <error>)
       (compile-statement '(if 1 2 3 4)))




(test-section "(when ...)")  ;{{{2

(test* "It should be compiled properly."
       (list (join "if 1" "echo 2" "endif")
             (join "if 1" "echo 2" "echo 3" "endif"))
       (map compile-statement
            '((when 1 (echo 2))
              (when 1 (echo 2) (echo 3)))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-statement '(when 1)))




(test-section "(unless ...)")  ;{{{2

(test* "It should be compiled properly."
       (list (join "if (!1)" "echo 2" "endif")
             (join "if (!1)" "echo 2" "echo 3" "endif"))
       (map compile-statement
            '((unless 1 (echo 2))
              (unless 1 (echo 2) (echo 3)))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-statement '(unless 1)))




(test-section "(while ...)")  ;{{{2

(test* "It should be compiled properly."
       (list (join "while 1" "echo 2" "endwhile")
             (join "while 1" "echo 2" "echo 3" "endwhile"))
       (list (compile-statement '(while 1 (echo 2)))
             (compile-statement '(while 1 (echo 2) (echo 3)))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-statement '(while 1)))




(test-section "(for ...)")  ;{{{2

(test* "It, 'for i in list', should be compiled properly."
       (list (join "for i in [1,2,3]" "echo i" "endfor")
             (join "for i in [1,2,3]" "echo i" "echo i i" "endfor"))
       (list (compile-statement '(for i (list 1 2 3) (echo i)))
             (compile-statement '(for i (list 1 2 3) (echo i) (echo i i)))))

(test* "It, 'for [i, ...] in list-of-lists', should be compiled properly."
       (list (join "for [i] in [[1],[2]]" "echo i" "endfor")
             (join "for [i,j] in [[1,2],[3,4]]" "echo i" "echo j" "endfor"))
       (list (compile-statement
               '(for (i) (list (list 1) (list 2)) (echo i)))
             (compile-statement
               '(for (i j) (list (list 1 2) (list 3 4)) (echo i) (echo j)))))

(test* "It should raise error if the number of operands is less than 3."
       (test-error <error>)
       (compile-statement '(for i (list 1 2 3))))




(test-section "(break)")  ;{{{2

(test* "It should be compiled properly."
       (join "break")
       (compile-statement '(break)))

(test* "It should raise error if the number of operands is greater than 0."
       (test-error <error>)
       (compile-statement '(break me down)))




(test-section "(continue)")  ;{{{2

(test* "It should be compiled properly."
       (join "continue")
       (compile-statement '(continue)))

(test* "It should raise error if the number of operands is greater than 0."
       (test-error <error>)
       (compile-statement '(continue me down)))




(test-section "(return ...)")  ;{{{2

(test* "It should be compiled properly."
       (list (join "return")
             (join "return 1")
             (join "return [1,2,3]"))
       (list (compile-statement '(return))
             (compile-statement '(return 1))
             (compile-statement '(return (list 1 2 3)))))

(test* "It should raise error if the number of operands is greater than 1."
       (test-error <error>)
       (compile-statement '(return of you)))




(test-section "(throw ...)")  ;{{{2

(test* "It should be compiled properly."
       (list (join "throw 1")
             (join "throw [1,2,3]"))
       (list (compile-statement '(throw 1))
             (compile-statement '(throw (list 1 2 3)))))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-statement '(throw)))

(test* "It should raise error if the number of operands is greater than 1."
       (test-error <error>)
       (compile-statement '(throw of you)))




; Functions  ;{{{1
(test-section "(abs ...)")  ;{{{2

(test* "It should be compiled properly."
       "(abs(1))"
       (compile-expression '(abs 1)))

; FIXME: Add tests for other built-in functions.




; Common utilities  ;{{{1
(test-section "(define-xire-statement-modifier)")  ;{{{2

(test* "It should define a valid modifier."
       (list (join "ctrl delete")
             (join "ctrl alt delete"))
       (parameterize ([xire-environment (xire-environment-copy)])
         (define-xire-statement-modifier control "ctrl")
         (define-xire-statement-modifier alt)
         (define-xire-statement delete "delete")
         (list (compile-statement '(control (delete)))
               (compile-statement '(control (alt (delete)))))))

(test* "It should not support multiple statements at the moment."
       (test-error <error>)
       (parameterize ([xire-environment (xire-environment-copy)])
         (define-xire-statement-modifier control "ctrl")
         (define-xire-statement delete "delete")
         (compile-statement '(control (delete)
                                      (delete)))))

(test* "It should fail if trailing script is not a valid statement."
       (test-error <error>)
       (parameterize ([xire-environment (xire-environment-copy)])
         (define-xire-statement-modifier control "ctrl")
         (compile-statement '(control (+ 1 2)))))




(test-section "(parse-++opt)")  ;{{{2

(test* "It should return the null list for option list without any content."
       '()
       (parse-++opt '()))

(test* "It should succeed for ordinary option list with a few options."
       '("++encoding=utf-8"
         "++fileformat=unix")
       (map tree->string
            (parse-++opt '(:encoding "utf-8"
                           :fileformat "unix"))))

(test* "It should succeed for ordinary option list with all options."
       '("++bad=X"
         "++binary"
         "++edit"
         "++encoding=utf-8"
         "++fileformat=unix"
         "++nobinary")
       (map tree->string
            (parse-++opt '(:bad "X"
                           :binary #t
                           :edit #t
                           :encoding "utf-8"
                           :fileformat "unix"
                           :nobinary #t))))

(test* "It should fail for invalid option list."
       (test-error <error>)
       (parse-++opt '(:invalid!? #t)))




; Other Ex commands  ;{{{1
(test-section "(aboveleft)")  ;{{{2

(test* "It should be compiled properly."
       "aboveleft edit\n"
       (compile-statement '(aboveleft (edit))))




(test-section "(belowright)")  ;{{{2

(test* "It should be compiled properly."
       "belowright edit\n"
       (compile-statement '(belowright (edit))))




(test-section "(botright)")  ;{{{2

(test* "It should be compiled properly."
       "botright edit\n"
       (compile-statement '(botright (edit))))




(test-section "(browse)")  ;{{{2

(test* "It should be compiled properly."
       "browse edit\n"
       (compile-statement '(browse (edit))))




(test-section "(confirm)")  ;{{{2

(test* "It should be compiled properly."
       "confirm edit\n"
       (compile-statement '(confirm (edit))))




(test-section "(echo expression ...)")  ;{{{2

(test* "It should be compiled properly."
       '("echo \n"
         "echo 1\n"
         "echo 1 2\n"
         "echo 1 (2 + 3)\n")
       (list (compile-statement '(echo))
             (compile-statement '(echo 1))
             (compile-statement '(echo 1 2))
             (compile-statement '(echo 1 (+ 2 3)))))




(test-section "(edit)")  ;{{{2

(test* "It should be compiled properly."
       '("edit\n"
         "edit `='ordinary-path'`\n"
         "edit `='path with spaces'`\n"
         "edit `='path''with\\strange`characters'`\n"
         "edit #\n"
         "edit #3\n"
         "edit `=(\"foo\" . \"bar\")`\n"
         "edit `find . -name ver\\\\*.c -print`\n"
         "edit ++encoding=utf-8 ++fileformat=unix `='foo'`\n")
       (map compile-statement
            '((edit)
              (edit "ordinary-path")
              (edit "path with spaces")
              (edit "path'with\\strange`characters")
              (edit :alternate)
              (edit :buffer 3)
              (edit :expression (.. "foo" "bar"))
              (edit :command "find . -name ver\\*.c -print")
              (edit "foo" :encoding "utf-8" :fileformat "unix"))))

(test* "It should fail for invalid form."
       (test-error <error>)
       (compile-statement '(edit foo bar)))




(test-section "(edit!)")  ;{{{2

(test* "It should be compiled properly."
       '("edit!\n"
         "edit! `='ordinary-path'`\n"
         "edit! `='path with spaces'`\n"
         "edit! `='path''with\\strange`characters'`\n"
         "edit! #\n"
         "edit! #3\n"
         "edit! `=(\"foo\" . \"bar\")`\n"
         "edit! `find . -name ver\\\\*.c -print`\n"
         "edit! ++encoding=utf-8 ++fileformat=unix `='foo'`\n")
       (map compile-statement
            '((edit!)
              (edit! "ordinary-path")
              (edit! "path with spaces")
              (edit! "path'with\\strange`characters")
              (edit! :alternate)
              (edit! :buffer 3)
              (edit! :expression (.. "foo" "bar"))
              (edit! :command "find . -name ver\\*.c -print")
              (edit! "foo" :encoding "utf-8" :fileformat "unix"))))

(test* "It should fail for invalid form."
       (test-error <error>)
       (compile-statement '(edit! foo bar)))




(test-section "(enew)")  ;{{{2

(test* "It should be compiled properly."
       "enew\n"
       (compile-statement '(enew)))

(test* "It should fail for invalid form."
       (test-error <error>)
       (compile-statement '(enew foo)))




(test-section "(enew!)")  ;{{{2

(test* "It should be compiled properly."
       "enew!\n"
       (compile-statement '(enew!)))

(test* "It should fail for invalid form."
       (test-error <error>)
       (compile-statement '(enew! foo)))




(test-section "(ex)")  ;{{{2

(test* "It should be compiled properly."
       '("ex\n"
         "ex `='ordinary-path'`\n"
         "ex `='path with spaces'`\n"
         "ex `='path''with\\strange`characters'`\n"
         "ex #\n"
         "ex #3\n"
         "ex `=(\"foo\" . \"bar\")`\n"
         "ex `find . -name ver\\\\*.c -print`\n"
         "ex ++encoding=utf-8 ++fileformat=unix `='foo'`\n")
       (map compile-statement
            '((ex)
              (ex "ordinary-path")
              (ex "path with spaces")
              (ex "path'with\\strange`characters")
              (ex :alternate)
              (ex :buffer 3)
              (ex :expression (.. "foo" "bar"))
              (ex :command "find . -name ver\\*.c -print")
              (ex "foo" :encoding "utf-8" :fileformat "unix"))))

(test* "It should fail for invalid form."
       (test-error <error>)
       (compile-statement '(ex foo bar)))




(test-section "(ex!)")  ;{{{2

(test* "It should be compiled properly."
       '("ex!\n"
         "ex! `='ordinary-path'`\n"
         "ex! `='path with spaces'`\n"
         "ex! `='path''with\\strange`characters'`\n"
         "ex! #\n"
         "ex! #3\n"
         "ex! `=(\"foo\" . \"bar\")`\n"
         "ex! `find . -name ver\\\\*.c -print`\n"
         "ex! ++encoding=utf-8 ++fileformat=unix `='foo'`\n")
       (map compile-statement
            '((ex!)
              (ex! "ordinary-path")
              (ex! "path with spaces")
              (ex! "path'with\\strange`characters")
              (ex! :alternate)
              (ex! :buffer 3)
              (ex! :expression (.. "foo" "bar"))
              (ex! :command "find . -name ver\\*.c -print")
              (ex! "foo" :encoding "utf-8" :fileformat "unix"))))

(test* "It should fail for invalid form."
       (test-error <error>)
       (compile-statement '(ex! foo bar)))




(test-section "(find)")  ;{{{2

(test* "It should be compiled properly."
       '("find\n"
         "find `='ordinary-path'`\n"
         "find `='path with spaces'`\n"
         "find `='path''with\\strange`characters'`\n"
         "find #\n"
         "find #3\n"
         "find `=(\"foo\" . \"bar\")`\n"
         "find `find . -name ver\\\\*.c -print`\n"
         "find ++encoding=utf-8 ++fileformat=unix `='foo'`\n")
       (map compile-statement
            '((find)
              (find "ordinary-path")
              (find "path with spaces")
              (find "path'with\\strange`characters")
              (find :alternate)
              (find :buffer 3)
              (find :expression (.. "foo" "bar"))
              (find :command "find . -name ver\\*.c -print")
              (find "foo" :encoding "utf-8" :fileformat "unix"))))

(test* "It should fail for invalid form."
       (test-error <error>)
       (compile-statement '(find foo bar)))




(test-section "(find!)")  ;{{{2

(test* "It should be compiled properly."
       '("find!\n"
         "find! `='ordinary-path'`\n"
         "find! `='path with spaces'`\n"
         "find! `='path''with\\strange`characters'`\n"
         "find! #\n"
         "find! #3\n"
         "find! `=(\"foo\" . \"bar\")`\n"
         "find! `find . -name ver\\\\*.c -print`\n"
         "find! ++encoding=utf-8 ++fileformat=unix `='foo'`\n")
       (map compile-statement
            '((find!)
              (find! "ordinary-path")
              (find! "path with spaces")
              (find! "path'with\\strange`characters")
              (find! :alternate)
              (find! :buffer 3)
              (find! :expression (.. "foo" "bar"))
              (find! :command "find . -name ver\\*.c -print")
              (find! "foo" :encoding "utf-8" :fileformat "unix"))))

(test* "It should fail for invalid form."
       (test-error <error>)
       (compile-statement '(find! foo bar)))




(test-section "(hide)")  ;{{{2

(test* "It should be compiled properly."
       "hide edit\n"
       (compile-statement '(hide (edit))))




(test-section "(keepalt)")  ;{{{2

(test* "It should be compiled properly."
       "keepalt edit\n"
       (compile-statement '(keepalt (edit))))




(test-section "(keepjumps)")  ;{{{2

(test* "It should be compiled properly."
       "keepjumps edit\n"
       (compile-statement '(keepjumps (edit))))




(test-section "(keepmarks)")  ;{{{2

(test* "It should be compiled properly."
       "keepmarks edit\n"
       (compile-statement '(keepmarks (edit))))




(test-section "(leftabove)")  ;{{{2

(test* "It should be compiled properly."
       "leftabove edit\n"
       (compile-statement '(leftabove (edit))))




(test-section "(lockmarks)")  ;{{{2

(test* "It should be compiled properly."
       "lockmarks edit\n"
       (compile-statement '(lockmarks (edit))))




(test-section "(noautocmd)")  ;{{{2

(test* "It should be compiled properly."
       "noautocmd edit\n"
       (compile-statement '(noautocmd (edit))))




(test-section "(rightbelow)")  ;{{{2

(test* "It should be compiled properly."
       "rightbelow edit\n"
       (compile-statement '(rightbelow (edit))))




(test-section "(sandbox)")  ;{{{2

(test* "It should be compiled properly."
       "sandbox edit\n"
       (compile-statement '(sandbox (edit))))




(test-section "(silent)")  ;{{{2

(test* "It should be compiled properly."
       "silent edit\n"
       (compile-statement '(silent (edit))))




(test-section "(tab)")  ;{{{2

(test* "It should be compiled properly."
       "tab edit\n"
       (compile-statement '(tab (edit))))




(test-section "(topleft)")  ;{{{2

(test* "It should be compiled properly."
       "topleft edit\n"
       (compile-statement '(topleft (edit))))




(test-section "(unsilent)")  ;{{{2

(test* "It should be compiled properly."
       "unsilent edit\n"
       (compile-statement '(unsilent (edit))))




(test-section "(verbose)")  ;{{{2

(test* "It should be compiled properly."
       "verbose edit\n"
       (compile-statement '(verbose (edit))))




(test-section "(vertical)")  ;{{{2

(test* "It should be compiled properly."
       "vertical edit\n"
       (compile-statement '(vertical (edit))))




(test-section "(view)")  ;{{{2

(test* "It should be compiled properly."
       '("view\n"
         "view `='ordinary-path'`\n"
         "view `='path with spaces'`\n"
         "view `='path''with\\strange`characters'`\n"
         "view #\n"
         "view #3\n"
         "view `=(\"foo\" . \"bar\")`\n"
         "view `find . -name ver\\\\*.c -print`\n"
         "view ++encoding=utf-8 ++fileformat=unix `='foo'`\n")
       (map compile-statement
            '((view)
              (view "ordinary-path")
              (view "path with spaces")
              (view "path'with\\strange`characters")
              (view :alternate)
              (view :buffer 3)
              (view :expression (.. "foo" "bar"))
              (view :command "find . -name ver\\*.c -print")
              (view "foo" :encoding "utf-8" :fileformat "unix"))))

(test* "It should fail for invalid form."
       (test-error <error>)
       (compile-statement '(view foo bar)))




(test-section "(view!)")  ;{{{2

(test* "It should be compiled properly."
       '("view!\n"
         "view! `='ordinary-path'`\n"
         "view! `='path with spaces'`\n"
         "view! `='path''with\\strange`characters'`\n"
         "view! #\n"
         "view! #3\n"
         "view! `=(\"foo\" . \"bar\")`\n"
         "view! `find . -name ver\\\\*.c -print`\n"
         "view! ++encoding=utf-8 ++fileformat=unix `='foo'`\n")
       (map compile-statement
            '((view!)
              (view! "ordinary-path")
              (view! "path with spaces")
              (view! "path'with\\strange`characters")
              (view! :alternate)
              (view! :buffer 3)
              (view! :expression (.. "foo" "bar"))
              (view! :command "find . -name ver\\*.c -print")
              (view! "foo" :encoding "utf-8" :fileformat "unix"))))

(test* "It should fail for invalid form."
       (test-error <error>)
       (compile-statement '(view! foo bar)))




(test-section "(visual)")  ;{{{2

(test* "It should be compiled properly."
       '("visual\n"
         "visual `='ordinary-path'`\n"
         "visual `='path with spaces'`\n"
         "visual `='path''with\\strange`characters'`\n"
         "visual #\n"
         "visual #3\n"
         "visual `=(\"foo\" . \"bar\")`\n"
         "visual `find . -name ver\\\\*.c -print`\n"
         "visual ++encoding=utf-8 ++fileformat=unix `='foo'`\n")
       (map compile-statement
            '((visual)
              (visual "ordinary-path")
              (visual "path with spaces")
              (visual "path'with\\strange`characters")
              (visual :alternate)
              (visual :buffer 3)
              (visual :expression (.. "foo" "bar"))
              (visual :command "find . -name ver\\*.c -print")
              (visual "foo" :encoding "utf-8" :fileformat "unix"))))

(test* "It should fail for invalid form."
       (test-error <error>)
       (compile-statement '(visual foo bar)))




(test-section "(visual!)")  ;{{{2

(test* "It should be compiled properly."
       '("visual!\n"
         "visual! `='ordinary-path'`\n"
         "visual! `='path with spaces'`\n"
         "visual! `='path''with\\strange`characters'`\n"
         "visual! #\n"
         "visual! #3\n"
         "visual! `=(\"foo\" . \"bar\")`\n"
         "visual! `find . -name ver\\\\*.c -print`\n"
         "visual! ++encoding=utf-8 ++fileformat=unix `='foo'`\n")
       (map compile-statement
            '((visual!)
              (visual! "ordinary-path")
              (visual! "path with spaces")
              (visual! "path'with\\strange`characters")
              (visual! :alternate)
              (visual! :buffer 3)
              (visual! :expression (.. "foo" "bar"))
              (visual! :command "find . -name ver\\*.c -print")
              (visual! "foo" :encoding "utf-8" :fileformat "unix"))))

(test* "It should fail for invalid form."
       (test-error <error>)
       (compile-statement '(visual! foo bar)))




;(test-section "template")  ;{{{1

;(test* "title"
;       expected-value
;       test-expression)




(test-end)  ;{{{1




; __END__
; vim: filetype=scheme foldmethod=marker
