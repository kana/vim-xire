; Test: xire-builtins  {{{1

(use gauche.test)
(test-start "xire-builtins")
(load "./bin/xirec")
(set! main #f)

(define (compile-expression expression)
  (define context (make-expression-context))
  (tree->string (xire-compile expression context)))

(define (compile-statement statement)
  (define context (make-statement-context))
  (tree->string (xire-compile statement context)))

(define (join . lines)
  (string-join lines "\n" 'suffix))




; Primitives  ;{{{1
(test-section "(RAW ...)")  ;{{{2

(test* "It should be compiled properly in statement context."
       '(""
         "\" Apple"
         "banana\ncherry\ndandelion\n")
       (list (compile-statement '(RAW ""))
             (compile-statement '(RAW "" "\"" " " "Apple"))
             (compile-statement '(RAW "banana\n" "cherry\n" "dandelion\n"))))




(test-section "comment")  ;{{{2

(test* "It should be available."
       #t
       (boolean (xire-lookup-macro 'comment (make-toplevel-context))))

(test* "It should compile a given form into a Vim-script comment."
       '("\"\n"
         "\" foo\n"
         "\" foo bar\n")
       (list (compile-statement '(comment))
             (compile-statement '(comment "foo"))
             (compile-statement '(comment "foo" "bar"))))

(test* "It should raise error for invalid arguments"
       (test-error <error>)
       (compile-statement '(comment "a" #\b "c")))




; Expression  ;{{{1
(test-section "(?: expression then-part else-part)")  ;{{{2

(test* "It should be compiled properly."
       "(0 ? 1 : 2)"
       (compile-expression '(?: 0 1 2)))

(test* "It should raise error if the number of operands is less than 3."
       (test-error <error>)
       (compile-expression '(?: 0 1)))

(test* "It should raise error if the number of operands is greater than 3."
       (test-error <error>)
       (compile-expression '(?: 0 1 2 3)))




(test-section "(or expression ..2)")  ;{{{2

(test* "It should be compiled properly."
       '("(1 || 2)"
         "(3 || 4 || 5)")
       (list (compile-expression '(or 1 2))
             (compile-expression '(or 3 4 5))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(or 1)))




(test-section "(and expression ..2)")  ;{{{2

(test* "It should be compiled properly."
       '("(1 && 2)"
         "(3 && 4 && 5)")
       (list (compile-expression '(and 1 2))
             (compile-expression '(and 3 4 5))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(and 1)))




(test-section "comparison operators")  ;{{{2

(test* "It should be available."
       '("(1 != 2)"
         "(1 !=# 2)"
         "(1 !=? 2)"
         "(1 !~ 2)"
         "(1 !~# 2)"
         "(1 !~? 2)"
         "(1 < 2)"
         "(1 <# 2)"
         "(1 <= 2)"
         "(1 <=# 2)"
         "(1 <=? 2)"
         "(1 <? 2)"
         "(1 == 2)"
         "(1 ==# 2)"
         "(1 ==? 2)"
         "(1 =~ 2)"
         "(1 =~# 2)"
         "(1 =~? 2)"
         "(1 > 2)"
         "(1 ># 2)"
         "(1 >= 2)"
         "(1 >=# 2)"
         "(1 >=? 2)"
         "(1 >? 2)"
         "(1 is 2)"
         "(1 is# 2)"
         "(1 is? 2)"
         "(1 isnot 2)"
         "(1 isnot# 2)"
         "(1 isnot? 2)")
       (map
         (lambda (operator) (compile-expression `(,operator 1 2)))
         '(!=
           !=#
           !=?
           !~
           !~#
           !~?
           <
           <#
           <=
           <=#
           <=?
           <?
           ==
           ==#
           ==?
           =~
           =~#
           =~?
           >
           >#
           >=
           >=#
           >=?
           >?
           is
           is#
           is?
           isnot
           isnot#
           isnot?)))




(test-section "(+ expression ..1)")  ;{{{2

(test* "It should be compiled properly."
       '("(0 + 999)"
         "(1 + 2)"
         "(3 + 4 + 5)")
       (list (compile-expression '(+ 999))
             (compile-expression '(+ 1 2))
             (compile-expression '(+ 3 4 5))))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-expression '(+)))




(test-section "(- expression ..1)")  ;{{{2

(test* "It should be compiled properly."
       '("(0 - 999)"
         "(1 - 2)"
         "(3 - 4 - 5)")
       (list (compile-expression '(- 999))
             (compile-expression '(- 1 2))
             (compile-expression '(- 3 4 5))))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-expression '(-)))




(test-section "(.. expression ..2)")  ;{{{2

(test* "It should be compiled properly."
       '("(\"1\" . \"2\")"
         "(\"3\" . \"4\" . \"5\")")
       (list (compile-expression '(.. "1" "2"))
             (compile-expression '(.. "3" "4" "5"))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(.. "0")))




(test-section "(* expression ..2)")  ;{{{2

(test* "It should be compiled properly."
       '("(1 * 2)"
         "(3 * 4 * 5)")
       (list (compile-expression '(* 1 2))
             (compile-expression '(* 3 4 5))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(* 999)))




(test-section "(/ expression ..2)")  ;{{{2

(test* "It should be compiled properly."
       '("(1 / 2)"
         "(3 / 4 / 5)")
       (list (compile-expression '(/ 1 2))
             (compile-expression '(/ 3 4 5))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(/ 999)))




(test-section "(% expression ..2)")  ;{{{2

(test* "It should be compiled properly."
       '("(1 % 2)"
         "(3 % 4 % 5)")
       (list (compile-expression '(% 1 2))
             (compile-expression '(% 3 4 5))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(% 999)))




(test-section "(not expression)")  ;{{{2

(test* "It should be compiled properly."
       "(!0)"
       (compile-expression '(not 0)))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-expression '(not)))

(test* "It should raise error if the number of operands is greater than 1."
       (test-error <error>)
       (compile-expression '(not 0 0)))




(test-section "(ref array index)")  ;{{{2

(test* "It should be compiled properly."
       "((array)[(123)])"
       (compile-expression '(ref array 123)))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(ref)))

(test* "It should raise error if the number of operands is greater than 2."
       (test-error <error>)
       (compile-expression '(ref 1 2 3)))




(test-section "(slice array index1 index2)")  ;{{{2

(test* "It should be compiled properly."
       '("((array)[(123):(456)])"
         "((array)[:(456)])"
         "((array)[(123):])")
       (list (compile-expression '(slice array 123 456))
             (compile-expression '(slice array #f 456))
             (compile-expression '(slice array 123 #f))))

(test* "It should raise error if the number of operands is less than 3."
       (test-error <error>)
       (compile-expression '(slice 123)))

(test* "It should raise error if the number of operands is greater than 3."
       (test-error <error>)
       (compile-expression '(slice 1 2 3 4)))




(test-section "(-> dictionary member)")  ;{{{2

(test* "It should be compiled properly."
       "((dictionary).member)"
       (compile-expression '(-> dictionary member)))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-expression '(-> dictionary)))

(test* "It should raise error if the number of operands is greater than 2."
       (test-error <error>)
       (compile-expression '(-> dictionary member more-member)))




(test-section "(apply function argument ...)")  ;{{{2

(test* "It should be compiled properly."
       '("(function())"
         "(function(1))"
         "(function(1,2))"
         "(function(1,2,3))")
       (list (compile-expression '(apply function))
             (compile-expression '(apply function 1))
             (compile-expression '(apply function 1 2))
             (compile-expression '(apply function 1 2 3))))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-expression '(apply)))




(test-section "(kbd key-sequence-string)")  ;{{{2

(test* "It should be compiled properly."
       '("\"\""
         "\"abc\""
         "\"\\<BS>\""
         "\"i\\\"foo'\\<BS>\\\"\""
         "\"<<\""
         "\"<<foo\\<C-x>bar>>\""
         "\"\\<Esc>/derive\\<Return>\\<Esc>A\\<C-w>new-topic\"")
       (map compile-expression
            '((kbd "")
              (kbd "abc")
              (kbd "<BS>")
              (kbd "i\"foo'<BS>\"")
              (kbd "<<")
              (kbd "<<foo<C-x>bar>>")
              (kbd "<Esc>/derive<Return><Esc>A<C-w>new-topic"))))




(test-section "(list expression ...)")  ;{{{2

(test* "It should be compiled properly."
       '("[]"
         "[1]"
         "[1,2]"
         "[1,2,3]")
       (list (compile-expression '(list))
             (compile-expression '(list 1))
             (compile-expression '(list 1 2))
             (compile-expression '(list 1 2 3))))




(test-section "(dict (key value) ...)")  ;{{{2

(test* "It should be compiled properly."
       '("{}"
         "{k1 : v1}"
         "{k1 : v1,k2 : v2}"
         "{k1 : v1,k2 : v2,k3 : v3}")
       (list (compile-expression '(dict))
             (compile-expression '(dict [k1 v1]))
             (compile-expression '(dict [k1 v1] [k2 v2]))
             (compile-expression '(dict [k1 v1] [k2 v2] [k3 v3]))))




(test-section "(& option)")  ;{{{2

(test* "It should be compiled properly."
       '("&option"
         "&l:option"
         "&g:option")
       (list (compile-expression '(& option))
             (compile-expression '(& l:option))
             (compile-expression '(& g:option))))

(test* "It should raise error if the given option name is not a symbol."
       (test-error <error>)
       (compile-expression '(& "string")))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-expression '(&)))

(test* "It should raise error if the number of operands is greater than 1."
       (test-error <error>)
       (compile-expression '(& foo bar)))




(test-section "($ variable)")  ;{{{2

(test* "It should be compiled properly."
       "$variable"
       (compile-expression '($ variable)))

(test* "It should raise error if the given option name is not a symbol."
       (test-error <error>)
       (compile-expression '($ "string")))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-expression '($)))

(test* "It should raise error if the number of operands is greater than 1."
       (test-error <error>)
       (compile-expression '($ foo bar)))




(test-section "(@ register)")  ;{{{2

(test* "It should be compiled properly."
       "@r"
       (compile-expression '(@ r)))

(test* "It should raise error if the given option name is not a symbol."
       (test-error <error>)
       (compile-expression '(@ "string")))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-expression '(@)))

(test* "It should raise error if the number of operands is greater than 1."
       (test-error <error>)
       (compile-expression '(@ foo bar)))




; Control flow  ;{{{1
(test-section "(begin ...)")  ;{{{2

(test* "It should be compiled properly."
       (list (join "echo 1")
             (join "echo 2" "echo 3")
             (join "echo 4" "echo 5" "echo 6"))
       (list (compile-statement '(begin (echo 1)))
             (compile-statement '(begin (echo 2) (echo 3)))
             (compile-statement '(begin (echo 4) (echo 5) (echo 6)))))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-statement '(begin)))




(test-section "(if ...)")  ;{{{2

(test* "It should be compiled properly."
       (list (join "if 1" "echo 2" "endif")
             (join "if 1" "echo 2" "else" "echo 3" "endif"))
       (list (compile-statement '(if 1 (echo 2)))
             (compile-statement '(if 1 (echo 2) (echo 3)))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-statement '(if 1)))

(test* "It should raise error if the number of operands is greater than 3."
       (test-error <error>)
       (compile-statement '(if 1 2 3 4)))




(test-section "(when ...)")  ;{{{2

(test* "It should be compiled properly."
       (list (join "if 1" "echo 2" "endif")
             (join "if 1" "echo 2" "echo 3" "endif"))
       (map compile-statement
            '((when 1 (echo 2))
              (when 1 (echo 2) (echo 3)))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-statement '(when 1)))




(test-section "(unless ...)")  ;{{{2

(test* "It should be compiled properly."
       (list (join "if (!1)" "echo 2" "endif")
             (join "if (!1)" "echo 2" "echo 3" "endif"))
       (map compile-statement
            '((unless 1 (echo 2))
              (unless 1 (echo 2) (echo 3)))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-statement '(unless 1)))




(test-section "(while ...)")  ;{{{2

(test* "It should be compiled properly."
       (list (join "while 1" "echo 2" "endwhile")
             (join "while 1" "echo 2" "echo 3" "endwhile"))
       (list (compile-statement '(while 1 (echo 2)))
             (compile-statement '(while 1 (echo 2) (echo 3)))))

(test* "It should raise error if the number of operands is less than 2."
       (test-error <error>)
       (compile-statement '(while 1)))




(test-section "(for ...)")  ;{{{2

(test* "It, 'for i in list', should be compiled properly."
       (list (join "for i in [1,2,3]" "echo i" "endfor")
             (join "for i in [1,2,3]" "echo i" "echo i i" "endfor"))
       (list (compile-statement '(for i (list 1 2 3) (echo i)))
             (compile-statement '(for i (list 1 2 3) (echo i) (echo i i)))))

(test* "It, 'for [i, ...] in list-of-lists', should be compiled properly."
       (list (join "for [i] in [[1],[2]]" "echo i" "endfor")
             (join "for [i,j] in [[1,2],[3,4]]" "echo i" "echo j" "endfor"))
       (list (compile-statement
               '(for (i) (list (list 1) (list 2)) (echo i)))
             (compile-statement
               '(for (i j) (list (list 1 2) (list 3 4)) (echo i) (echo j)))))

(test* "It should raise error if the number of operands is less than 3."
       (test-error <error>)
       (compile-statement '(for i (list 1 2 3))))




(test-section "(break)")  ;{{{2

(test* "It should be compiled properly."
       (join "break")
       (compile-statement '(break)))

(test* "It should raise error if the number of operands is greater than 0."
       (test-error <error>)
       (compile-statement '(break me down)))




(test-section "(continue)")  ;{{{2

(test* "It should be compiled properly."
       (join "continue")
       (compile-statement '(continue)))

(test* "It should raise error if the number of operands is greater than 0."
       (test-error <error>)
       (compile-statement '(continue me down)))




(test-section "(return ...)")  ;{{{2

(test* "It should be compiled properly."
       (list (join "return")
             (join "return 1")
             (join "return [1,2,3]"))
       (list (compile-statement '(return))
             (compile-statement '(return 1))
             (compile-statement '(return (list 1 2 3)))))

(test* "It should raise error if the number of operands is greater than 1."
       (test-error <error>)
       (compile-statement '(return of you)))




(test-section "(throw ...)")  ;{{{2

(test* "It should be compiled properly."
       (list (join "throw 1")
             (join "throw [1,2,3]"))
       (list (compile-statement '(throw 1))
             (compile-statement '(throw (list 1 2 3)))))

(test* "It should raise error if the number of operands is less than 1."
       (test-error <error>)
       (compile-statement '(throw)))

(test* "It should raise error if the number of operands is greater than 1."
       (test-error <error>)
       (compile-statement '(throw of you)))




; Functions  ;{{{1
(test-section "(abs ...)")  ;{{{2

(test* "It should be compiled properly."
       "(abs(1))"
       (compile-expression '(abs 1)))

; FIXME: Add tests for other built-in functions.




; Common utilities  ;{{{1
(test-section "(compile-++opt)")  ;{{{2

(test* "It should return empty string for option list without any content."
       ""
       (tree->string (compile-++opt '())))

(test* "It should return compiled result option list with a few options."
       (string-join '("++encoding=utf-8"
                      "++fileformat=unix")
                    " "
                    'prefix)
       (tree->string
         (compile-++opt '(:encoding "utf-8"
                          :fileformat "unix"))))

(test* "It should succeed for ordinary option list with all options."
       (string-join '("++bad=X"
                      "++binary"
                      "++edit"
                      "++encoding=utf-8"
                      "++fileformat=unix"
                      "++nobinary")
                    " "
                    'prefix)
       (tree->string
         (compile-++opt '(:bad "X"
                          :binary #t
                          :edit #t
                          :encoding "utf-8"
                          :fileformat "unix"
                          :nobinary #t))))

(test* "It should fail for invalid option list."
       (test-error <error>)
       (compile-++opt '(:invalid!? #t)))




(test-section "(compile-path)")  ;{{{2

(test* "It should compile a valid path properly."
       '("`='foo''bar'`"
         "#"
         "#3"
         "`echo 'fo\\\\o'`"
         "`=(\"foo\" . \"bar\")`"
         "**/%<.[ch]")
       (map (compose tree->string
                     (cut compile-path <> (make-statement-context)))
            '("foo'bar"
              (:alternate)
              (:buffer 3)
              (:command "echo 'fo\\o'")
              (:expression (.. "foo" "bar"))
              (:raw "**/%<.[ch]"))))

(test* "It should fail for invalid path."
       (test-error <error>)
       (compile-path '(:invalid "path") (make-statement-context)))




(test-section "(compile-paths)")  ;{{{2

(test* "It should compile valid paths properly."
       (string-join '("`='foo''bar'`"
                      "#"
                      "#3"
                      "`echo 'fo\\\\o'`"
                      "`=(\"foo\" . \"bar\")`"
                      "**/%<.[ch]")
                    " ")
       (tree->string
         (compile-paths 
           '("foo'bar"
             (:alternate)
             (:buffer 3)
             (:command "echo 'fo\\o'")
             (:expression (.. "foo" "bar"))
             (:raw "**/%<.[ch]"))
           (make-statement-context))))

(test* "It should fail for invalid paths."
       (test-error <error>)
       (compile-paths '((:invalid "path")) (make-statement-context)))




(test-section "(define-xire-statement-modifier)")  ;{{{2

(test* "It should define a valid modifier."
       (list (join "ctrl delete")
             (join "ctrl alt delete"))
       (parameterize ([xire-environment (xire-environment-copy)])
         (define-xire-statement-modifier control "ctrl")
         (define-xire-statement-modifier alt)
         (define-xire-statement delete "delete")
         (list (compile-statement '(control (delete)))
               (compile-statement '(control (alt (delete)))))))

(test* "It should not support multiple statements at the moment."
       (test-error <error>)
       (parameterize ([xire-environment (xire-environment-copy)])
         (define-xire-statement-modifier control "ctrl")
         (define-xire-statement delete "delete")
         (compile-statement '(control (delete)
                                      (delete)))))

(test* "It should fail if trailing script is not a valid statement."
       (test-error <error>)
       (parameterize ([xire-environment (xire-environment-copy)])
         (define-xire-statement-modifier control "ctrl")
         (compile-statement '(control (+ 1 2)))))




(test-section "(escape-path)")  ;{{{2

(test* "It should escape a given path properly."
       '("`=''`"
         "`=''''`"
         "`='\\'`"
         "`='\"'`"
         "`='%'`"
         "`='#'`"
         "`='|'`"
         "`='''\\\" %#|'`"
         "`='Apple Banana Cherry'`")
       (map (compose tree->string escape-path)
            '(""
              "'"
              "\\"
              "\""
              "%"
              "#"
              "|"
              "'\\\" %#|"
              "Apple Banana Cherry")))

(test* "It should fail for non-string argument."
       (test-error <error>)
       (escape-path 'symbol))




(test-section "(parse-++opt)")  ;{{{2

(test* "It should return the null list for option list without any content."
       '()
       (parse-++opt '()))

(test* "It should succeed for ordinary option list with a few options."
       '("++encoding=utf-8"
         "++fileformat=unix")
       (map tree->string
            (parse-++opt '(:encoding "utf-8"
                           :fileformat "unix"))))

(test* "It should succeed for ordinary option list with all options."
       '("++bad=X"
         "++binary"
         "++edit"
         "++encoding=utf-8"
         "++fileformat=unix"
         "++nobinary")
       (map tree->string
            (parse-++opt '(:bad "X"
                           :binary #t
                           :edit #t
                           :encoding "utf-8"
                           :fileformat "unix"
                           :nobinary #t))))

(test* "It should fail for invalid option list."
       (test-error <error>)
       (parse-++opt '(:invalid!? #t)))




(test-section "(path-pattern?)")  ;{{{2

(test* "It should return true for a path."
       '(#t #t #t #t #t #t)
       (map path-pattern?
            '("ordinary path"
              (:alternate)
              (:buffer 3)
              (:command "echo 'foo'")
              (:expression (.. "foo" "bar"))
              (:this-is-not-valid "but" "accepted"))))

(test* "It should return false for a non-path."
       '(#f #f #f #f #f)
       (map path-pattern?
            '(not-a-path
              (alternate)
              (buffer 3)
              (command "echo 'foo'")
              (expression (.. "foo" "bar")))))




; Other Ex commands  ;{{{1
(test-section "(aboveleft)")  ;{{{2

(test* "It should be compiled properly."
       "aboveleft edit\n"
       (compile-statement '(aboveleft (edit))))




(test-section "(argadd)")  ;{{{2

(test* "It should be compiled properly."
       (list (join "argadd `='foo'`")
             (join "argadd `='foo'` `='bar'`")
             (join "8argadd `='foo'` `='bar'`"))
       (map compile-statement
            '((argadd "foo")
              (argadd ("foo" "bar"))
              (argadd ("foo" "bar") :count 8))))

(test* "It should fail without any argument."
       (test-error <error>)
       (compile-statement '(argadd)))

(test* "It should fail with invalid path."
       (test-error <error>)
       (compile-statement '(argadd 'invalid-path)))

(test* "It should fail without a path."
       (test-error <error>)
       (compile-statement '(argadd :count 8)))




(test-section "(argedit)")  ;{{{2

(test* "It should be compiled properly."
       (list (join "argedit `='foo'`")
             (join "argedit ++encoding=utf-8 `='foo'`")
             (join "8argedit ++encoding=utf-8 `='foo'`"))
       (map compile-statement
            '((argedit "foo")
              (argedit "foo" :encoding "utf-8")
              (argedit "foo" :count 8 :encoding "utf-8"))))

(test* "It should fail without any argument."
       (test-error <error>)
       (compile-statement '(argedit)))

(test* "It should fail with invalid path."
       (test-error <error>)
       (compile-statement '(argedit 'invalid-path)))

(test* "It should fail without a path."
       (test-error <error>)
       (compile-statement '(argedit :encoding utf-8)))




(test-section "(argedit!)")  ;{{{2

(test* "It should be compiled properly."
       (list (join "argedit! `='foo'`")
             (join "argedit! ++encoding=utf-8 `='foo'`")
             (join "8argedit! ++encoding=utf-8 `='foo'`"))
       (map compile-statement
            '((argedit! "foo")
              (argedit! "foo" :encoding "utf-8")
              (argedit! "foo" :count 8 :encoding "utf-8"))))

(test* "It should fail without any argument."
       (test-error <error>)
       (compile-statement '(argedit!)))

(test* "It should fail with invalid path."
       (test-error <error>)
       (compile-statement '(argedit! 'invalid-path)))

(test* "It should fail without a path."
       (test-error <error>)
       (compile-statement '(argedit! :encoding utf-8)))




(test-section "(args)")  ;{{{2

(test* "It should be compiled properly."
       (list (join "args")
             (join "args ++encoding=utf-8 `='foo'`")
             (join "args **/*.c **/*.h"))
       (map compile-statement
            '((args)
              (args "foo" :encoding "utf-8")
              (args ((:raw "**/*.c") (:raw "**/*.h"))))))

(test* "It should fail for invalid argument."
       (test-error <error>)
       (compile-statement '(args 0)))




(test-section "(args!)")  ;{{{2

(test* "It should be compiled properly."
       (list (join "args!")
             (join "args! ++encoding=utf-8 `='foo'`")
             (join "args! **/*.c **/*.h"))
       (map compile-statement
            '((args!)
              (args! "foo" :encoding "utf-8")
              (args! ((:raw "**/*.c") (:raw "**/*.h"))))))

(test* "It should fail for invalid argument."
       (test-error <error>)
       (compile-statement '(args! 0)))




(test-section "(ascii)")  ;{{{2

(test* "It should be compiled properly."
       "ascii\n"
       (compile-statement '(ascii)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(ascii foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(ascii!)))




(test-section "(belowright)")  ;{{{2

(test* "It should be compiled properly."
       "belowright edit\n"
       (compile-statement '(belowright (edit))))




(test-section "(botright)")  ;{{{2

(test* "It should be compiled properly."
       "botright edit\n"
       (compile-statement '(botright (edit))))




(test-section "(browse)")  ;{{{2

(test* "It should be compiled properly."
       "browse edit\n"
       (compile-statement '(browse (edit))))




(test-section "(buffers)")  ;{{{2

(test* "It should be compiled properly."
       "buffers\n"
       (compile-statement '(buffers)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(buffers foo)))

(test* "It should be compiled properly with bang."
       "buffers!\n"
       (compile-statement '(buffers!)))




(test-section "(call)")  ;{{{2

(test* "It should be compiled properly (1)."
       "call (getcwd())\n"
       (compile-statement '(call (getcwd))))

(test* "It should be compiled properly (2)."
       "call (setreg(\"g\",content,type))\n"
       (compile-statement '(call (setreg "g" content type))))

(test* "It should fail with non-function-calling expression."
       (test-error <error>)
       (compile-statement '(call this-is-not-a-function-call)))

(test* "It should fail with insufficient arguments."
       (test-error <error>)
       (compile-statement '(call)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(call (getcwd) (getcwd))))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(call! (getcwd))))




(test-section "(changes)")  ;{{{2

(test* "It should be compiled properly."
       "changes\n"
       (compile-statement '(changes)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(changes foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(changes!)))




(test-section "(checkpath)")  ;{{{2

(test* "It should be compiled properly."
       "checkpath\n"
       (compile-statement '(checkpath)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(checkpath foo)))

(test* "It should be compiled properly with bang."
       "checkpath!\n"
       (compile-statement '(checkpath!)))




(test-section "(close)")  ;{{{2

(test* "It should be compiled properly."
       "close\n"
       (compile-statement '(close)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(close foo)))

(test* "It should be compiled properly with bang."
       "close!\n"
       (compile-statement '(close!)))




(test-section "(comclear)")  ;{{{2

(test* "It should be compiled properly."
       "comclear\n"
       (compile-statement '(comclear)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(comclear foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(comclear!)))




(test-section "(confirm)")  ;{{{2

(test* "It should be compiled properly."
       "confirm edit\n"
       (compile-statement '(confirm (edit))))




(test-section "(cquit)")  ;{{{2

(test* "It should be compiled properly."
       "cquit\n"
       (compile-statement '(cquit)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(cquit foo)))

(test* "It should be compiled properly with bang."
       "cquit!\n"
       (compile-statement '(cquit!)))




(test-section "(diffoff)")  ;{{{2

(test* "It should be compiled properly."
       "diffoff\n"
       (compile-statement '(diffoff)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(diffoff foo)))

(test* "It should be compiled properly with bang."
       "diffoff!\n"
       (compile-statement '(diffoff!)))




(test-section "(diffthis)")  ;{{{2

(test* "It should be compiled properly."
       "diffthis\n"
       (compile-statement '(diffthis)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(diffthis foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(diffthis!)))




(test-section "(diffupdate)")  ;{{{2

(test* "It should be compiled properly."
       "diffupdate\n"
       (compile-statement '(diffupdate)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(diffupdate foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(diffupdate!)))




(test-section "(echo expression ...)")  ;{{{2

(test* "It should be compiled properly."
       '("echo \n"
         "echo 1\n"
         "echo 1 2\n"
         "echo 1 (2 + 3)\n")
       (list (compile-statement '(echo))
             (compile-statement '(echo 1))
             (compile-statement '(echo 1 2))
             (compile-statement '(echo 1 (+ 2 3)))))




(test-section "(edit)")  ;{{{2

(test* "It should be compiled properly."
       '("edit\n"
         "edit `='ordinary-path'`\n"
         "edit `='path with spaces'`\n"
         "edit `='path''with\\strange`characters'`\n"
         "edit #\n"
         "edit #3\n"
         "edit `=(\"foo\" . \"bar\")`\n"
         "edit `find . -name ver\\\\*.c -print`\n"
         "edit ++encoding=utf-8 ++fileformat=unix `='foo'`\n")
       (map compile-statement
            '((edit)
              (edit "ordinary-path")
              (edit "path with spaces")
              (edit "path'with\\strange`characters")
              (edit (:alternate))
              (edit (:buffer 3))
              (edit (:expression (.. "foo" "bar")))
              (edit (:command "find . -name ver\\*.c -print"))
              (edit "foo" :encoding "utf-8" :fileformat "unix"))))

(test* "It should fail for invalid form."
       (test-error <error>)
       (compile-statement '(edit foo bar)))




(test-section "(edit!)")  ;{{{2

(test* "It should be compiled properly."
       '("edit!\n"
         "edit! `='ordinary-path'`\n"
         "edit! `='path with spaces'`\n"
         "edit! `='path''with\\strange`characters'`\n"
         "edit! #\n"
         "edit! #3\n"
         "edit! `=(\"foo\" . \"bar\")`\n"
         "edit! `find . -name ver\\\\*.c -print`\n"
         "edit! ++encoding=utf-8 ++fileformat=unix `='foo'`\n")
       (map compile-statement
            '((edit!)
              (edit! "ordinary-path")
              (edit! "path with spaces")
              (edit! "path'with\\strange`characters")
              (edit! (:alternate))
              (edit! (:buffer 3))
              (edit! (:expression (.. "foo" "bar")))
              (edit! (:command "find . -name ver\\*.c -print"))
              (edit! "foo" :encoding "utf-8" :fileformat "unix"))))

(test* "It should fail for invalid form."
       (test-error <error>)
       (compile-statement '(edit! foo bar)))




(test-section "(enew)")  ;{{{2

(test* "It should be compiled properly."
       "enew\n"
       (compile-statement '(enew)))

(test* "It should fail for invalid form."
       (test-error <error>)
       (compile-statement '(enew foo)))




(test-section "(enew!)")  ;{{{2

(test* "It should be compiled properly."
       "enew!\n"
       (compile-statement '(enew!)))

(test* "It should fail for invalid form."
       (test-error <error>)
       (compile-statement '(enew! foo)))




(test-section "(ex)")  ;{{{2

(test* "It should be compiled properly."
       '("ex\n"
         "ex `='ordinary-path'`\n"
         "ex `='path with spaces'`\n"
         "ex `='path''with\\strange`characters'`\n"
         "ex #\n"
         "ex #3\n"
         "ex `=(\"foo\" . \"bar\")`\n"
         "ex `find . -name ver\\\\*.c -print`\n"
         "ex ++encoding=utf-8 ++fileformat=unix `='foo'`\n")
       (map compile-statement
            '((ex)
              (ex "ordinary-path")
              (ex "path with spaces")
              (ex "path'with\\strange`characters")
              (ex (:alternate))
              (ex (:buffer 3))
              (ex (:expression (.. "foo" "bar")))
              (ex (:command "find . -name ver\\*.c -print"))
              (ex "foo" :encoding "utf-8" :fileformat "unix"))))

(test* "It should fail for invalid form."
       (test-error <error>)
       (compile-statement '(ex foo bar)))




(test-section "(ex!)")  ;{{{2

(test* "It should be compiled properly."
       '("ex!\n"
         "ex! `='ordinary-path'`\n"
         "ex! `='path with spaces'`\n"
         "ex! `='path''with\\strange`characters'`\n"
         "ex! #\n"
         "ex! #3\n"
         "ex! `=(\"foo\" . \"bar\")`\n"
         "ex! `find . -name ver\\\\*.c -print`\n"
         "ex! ++encoding=utf-8 ++fileformat=unix `='foo'`\n")
       (map compile-statement
            '((ex!)
              (ex! "ordinary-path")
              (ex! "path with spaces")
              (ex! "path'with\\strange`characters")
              (ex! (:alternate))
              (ex! (:buffer 3))
              (ex! (:expression (.. "foo" "bar")))
              (ex! (:command "find . -name ver\\*.c -print"))
              (ex! "foo" :encoding "utf-8" :fileformat "unix"))))

(test* "It should fail for invalid form."
       (test-error <error>)
       (compile-statement '(ex! foo bar)))




(test-section "(execute)")  ;{{{2

(test* "It should be compiled properly."
       (list (join "execute")
             (join "execute \"echo\"")
             (join "execute \"echo\" (1 + 3)"))
       (map compile-statement
            '((execute)
              (execute "echo")
              (execute "echo" (+ 1 3)))))

(test* "It should fail if invalid expression is given."
       (test-error <error>)
       (compile-statement `(execute ,(lambda () 'dummy))))




(test-section "(exusage)")  ;{{{2

(test* "It should be compiled properly."
       "exusage\n"
       (compile-statement '(exusage)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(exusage foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(exusage!)))




(test-section "(file)")  ;{{{2

(test* "It should be compiled properly."
       (list (join "file")
             (join "0file")
             (join "file `='foo bar baz'`")
             (join "file #3"))
       (map compile-statement
            '((file)
              (file #f)
              (file "foo bar baz")
              (file (:buffer 3)))))

(test* "It should fail if too many arguments are given."
       (test-error <error>)
       (compile-statement '(file "foo" "bar")))

(test* "It should fail if non-#f and non-string argument is given."
       (test-error <error>)
       (compile-statement '(file #t)))




(test-section "(file!)")  ;{{{2

(test* "It should be compiled properly."
       (list (join "file!")
             (join "0file!")
             (join "file! `='foo bar baz'`")
             (join "file! #3"))
       (map compile-statement
            '((file!)
              (file! #f)
              (file! "foo bar baz")
              (file! (:buffer 3)))))

(test* "It should fail if too many arguments are given."
       (test-error <error>)
       (compile-statement '(file! "foo" "bar")))

(test* "It should fail if non-#f and non-string argument is given."
       (test-error <error>)
       (compile-statement '(file! #t)))




(test-section "(files)")  ;{{{2

(test* "It should be compiled properly."
       "files\n"
       (compile-statement '(files)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(files foo)))

(test* "It should be compiled properly with bang."
       "files!\n"
       (compile-statement '(files!)))




(test-section "(find)")  ;{{{2

(test* "It should be compiled properly."
       '("find\n"
         "find `='ordinary-path'`\n"
         "find `='path with spaces'`\n"
         "find `='path''with\\strange`characters'`\n"
         "find #\n"
         "find #3\n"
         "find `=(\"foo\" . \"bar\")`\n"
         "find `find . -name ver\\\\*.c -print`\n"
         "find ++encoding=utf-8 ++fileformat=unix `='foo'`\n")
       (map compile-statement
            '((find)
              (find "ordinary-path")
              (find "path with spaces")
              (find "path'with\\strange`characters")
              (find (:alternate))
              (find (:buffer 3))
              (find (:expression (.. "foo" "bar")))
              (find (:command "find . -name ver\\*.c -print"))
              (find "foo" :encoding "utf-8" :fileformat "unix"))))

(test* "It should fail for invalid form."
       (test-error <error>)
       (compile-statement '(find foo bar)))




(test-section "(find!)")  ;{{{2

(test* "It should be compiled properly."
       '("find!\n"
         "find! `='ordinary-path'`\n"
         "find! `='path with spaces'`\n"
         "find! `='path''with\\strange`characters'`\n"
         "find! #\n"
         "find! #3\n"
         "find! `=(\"foo\" . \"bar\")`\n"
         "find! `find . -name ver\\\\*.c -print`\n"
         "find! ++encoding=utf-8 ++fileformat=unix `='foo'`\n")
       (map compile-statement
            '((find!)
              (find! "ordinary-path")
              (find! "path with spaces")
              (find! "path'with\\strange`characters")
              (find! (:alternate))
              (find! (:buffer 3))
              (find! (:expression (.. "foo" "bar")))
              (find! (:command "find . -name ver\\*.c -print"))
              (find! "foo" :encoding "utf-8" :fileformat "unix"))))

(test* "It should fail for invalid form."
       (test-error <error>)
       (compile-statement '(find! foo bar)))




(test-section "(finish)")  ;{{{2

(test* "It should be compiled properly."
       "finish\n"
       (compile-statement '(finish)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(finish foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(finish!)))




(test-section "(fixdel)")  ;{{{2

(test* "It should be compiled properly."
       "fixdel\n"
       (compile-statement '(fixdel)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(fixdel foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(fixdel!)))




(test-section "(function)")  ;{{{2

(test* "It should be compiled properly without any option."
       (join
         "function F(a,b,c,...)"
         "let sum = (a:a + a:b + a:c + a:000)"
         "return sum"
         "endfunction")
       (compile-statement '(function (F a b c ...)
                             (let sum (+ a:a a:b a:c a:000))
                             (return sum))))

(test* "It should be compiled properly with bang."
       (join
         "function! F(a,b,c,...)"
         "let sum = (a:a + a:b + a:c + a:000)"
         "return sum"
         "endfunction")
       (compile-statement '(function! (F a b c ...)
                             (let sum (+ a:a a:b a:c a:000))
                             (return sum))))

(test* "It should be compiled properly with attributes."
       (join
         "function F(a,b,c,...) abort dict range"
         "let sum = (a:a + a:b + a:c + a:000)"
         "return sum"
         "endfunction")
       (compile-statement '(function (F a b c ...) (:abort :dict :range)
                             (let sum (+ a:a a:b a:c a:000))
                             (return sum))))




(test-section "(hide)")  ;{{{2

(test* "It should be compiled properly."
       "hide edit\n"
       (compile-statement '(hide (edit))))




(test-section "(intro)")  ;{{{2

(test* "It should be compiled properly."
       "intro\n"
       (compile-statement '(intro)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(intro foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(intro!)))




(test-section "(jumps)")  ;{{{2

(test* "It should be compiled properly."
       "jumps\n"
       (compile-statement '(jumps)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(jumps foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(jumps!)))




(test-section "(keepalt)")  ;{{{2

(test* "It should be compiled properly."
       "keepalt edit\n"
       (compile-statement '(keepalt (edit))))




(test-section "(keepjumps)")  ;{{{2

(test* "It should be compiled properly."
       "keepjumps edit\n"
       (compile-statement '(keepjumps (edit))))




(test-section "(keepmarks)")  ;{{{2

(test* "It should be compiled properly."
       "keepmarks edit\n"
       (compile-statement '(keepmarks (edit))))




(test-section "(leftabove)")  ;{{{2

(test* "It should be compiled properly."
       "leftabove edit\n"
       (compile-statement '(leftabove (edit))))




(test-section "(let)")  ;{{{2

(test* "It should be compiled properly."
       (list (join "let")
             (join "let variable")
             (join "let s:")
             (join "let apple = (1 + 2)")
             (join "let g:apple = \"sweet\"")
             (join "let @a = \"sweet\"")
             (join "let &apple = \"sweet\"")
             (join "let &l:apple = \"sweet\"")
             (join "let ((apple)[((1 + 2))]) = \"sweet\"")
             (join "let ((apple)[(\"core\")]) = \"bitter\"")
             (join "let ((apple)[(1):(2)]) = \"empty\""))
       (map compile-statement
            '((let)
              (let variable)
              (let s:)
              (let apple (+ 1 2))
              (let g:apple "sweet")
              (let (@ a) "sweet")
              (let (& apple) "sweet")
              (let (& l:apple) "sweet")
              (let (ref apple (+ 1 2)) "sweet")
              (let (ref apple "core") "bitter")
              (let (slice apple 1 2) "empty"))))

(test* "It should fail for invalid form - too many arguments."
       (test-error <error>)
       (compile-statement '(let x y z)))

(test* "It should fail for invalid form - invalid expression."
       (test-error <error>)
       (compile-statement `(let x ,(lambda () 'dummy))))

(test* "It should fail for invalid form - invalid variable name."
       (test-error <error>)
       (compile-statement `(let ,(lambda () 'dummy) z)))




(test-section "(loadkeymap)")  ;{{{2

(test* "It should be compiled properly."
       "loadkeymap\n"
       (compile-statement '(loadkeymap)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(loadkeymap foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(loadkeymap!)))




(test-section "(lockmarks)")  ;{{{2

(test* "It should be compiled properly."
       "lockmarks edit\n"
       (compile-statement '(lockmarks (edit))))




(test-section "(ls)")  ;{{{2

(test* "It should be compiled properly."
       "ls\n"
       (compile-statement '(ls)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(ls foo)))

(test* "It should be compiled properly with bang."
       "ls!\n"
       (compile-statement '(ls!)))




(test-section "(map)")  ;{{{2

(let1 commands '(map map! cmap imap lmap
                 nmap omap smap vmap xmap
                 noremap noremap! cnoremap inoremap lnoremap
                 nnoremap onoremap snoremap vnoremap xnoremap)
  (map
    (lambda (c)
      (test* "It should be compiled properly."
             (list
               #`",c  lhs rhs\n"
               #`",c <buffer><expr><script><special><unique> lhs \"rhs\"\n")
             (map
               (cut compile-statement <>)
               `((,c () "lhs" "rhs")
                 (,c (:buffer :expr :script :special :unique) "lhs" "rhs"))))
      (test* "It should accept form without options."
             (compile-statement `(,c () "lhs" "rhs"))
             (compile-statement `(,c "lhs" "rhs")))
      (test* "It should fail if invalid option is given."
             (test-error <error>)
             (compile-statement `(,c (<x>) "lhs" "rhs")))
      (test* "It should fail if non-string rhs is given for non-<expr> mode."
             (test-error <error>)
             (compile-statement `(,c () "lhs" rhs))))
    commands))




(test-section "(messages)")  ;{{{2

(test* "It should be compiled properly."
       "messages\n"
       (compile-statement '(messages)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(messages foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(messages!)))




(test-section "(noautocmd)")  ;{{{2

(test* "It should be compiled properly."
       "noautocmd edit\n"
       (compile-statement '(noautocmd (edit))))




(test-section "(nohlsearch)")  ;{{{2

(test* "It should be compiled properly."
       "nohlsearch\n"
       (compile-statement '(nohlsearch)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(nohlsearch foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(nohlsearch!)))




(test-section "(oldfiles)")  ;{{{2

(test* "It should be compiled properly."
       "oldfiles\n"
       (compile-statement '(oldfiles)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(oldfiles foo)))

(test* "It should be compiled properly with bang."
       "oldfiles!\n"
       (compile-statement '(oldfiles!)))




(test-section "(only)")  ;{{{2

(test* "It should be compiled properly."
       "only\n"
       (compile-statement '(only)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(only foo)))

(test* "It should be compiled properly with bang."
       "only!\n"
       (compile-statement '(only!)))




(test-section "(options)")  ;{{{2

(test* "It should be compiled properly."
       "options\n"
       (compile-statement '(options)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(options foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(options!)))




(test-section "(pclose)")  ;{{{2

(test* "It should be compiled properly."
       "pclose\n"
       (compile-statement '(pclose)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(pclose foo)))

(test* "It should be compiled properly with bang."
       "pclose!\n"
       (compile-statement '(pclose!)))




(test-section "(preserve)")  ;{{{2

(test* "It should be compiled properly."
       "preserve\n"
       (compile-statement '(preserve)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(preserve foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(preserve!)))




(test-section "(ptlast)")  ;{{{2

(test* "It should be compiled properly."
       "ptlast\n"
       (compile-statement '(ptlast)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(ptlast foo)))

(test* "It should be compiled properly with bang."
       "ptlast!\n"
       (compile-statement '(ptlast!)))




(test-section "(pwd)")  ;{{{2

(test* "It should be compiled properly."
       "pwd\n"
       (compile-statement '(pwd)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(pwd foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(pwd!)))




(test-section "(qall)")  ;{{{2

(test* "It should be compiled properly."
       "qall\n"
       (compile-statement '(qall)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(qall foo)))

(test* "It should be compiled properly with bang."
       "qall!\n"
       (compile-statement '(qall!)))




(test-section "(quit)")  ;{{{2

(test* "It should be compiled properly."
       "quit\n"
       (compile-statement '(quit)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(quit foo)))

(test* "It should be compiled properly with bang."
       "quit!\n"
       (compile-statement '(quit!)))




(test-section "(quitall)")  ;{{{2

(test* "It should be compiled properly."
       "quitall\n"
       (compile-statement '(quitall)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(quitall foo)))

(test* "It should be compiled properly with bang."
       "quitall!\n"
       (compile-statement '(quitall!)))




(test-section "(redo)")  ;{{{2

(test* "It should be compiled properly."
       "redo\n"
       (compile-statement '(redo)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(redo foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(redo!)))




(test-section "(redraw)")  ;{{{2

(test* "It should be compiled properly."
       "redraw\n"
       (compile-statement '(redraw)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(redraw foo)))

(test* "It should be compiled properly with bang."
       "redraw!\n"
       (compile-statement '(redraw!)))




(test-section "(redrawstatus)")  ;{{{2

(test* "It should be compiled properly."
       "redrawstatus\n"
       (compile-statement '(redrawstatus)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(redrawstatus foo)))

(test* "It should be compiled properly with bang."
       "redrawstatus!\n"
       (compile-statement '(redrawstatus!)))




(test-section "(rightbelow)")  ;{{{2

(test* "It should be compiled properly."
       "rightbelow edit\n"
       (compile-statement '(rightbelow (edit))))




(test-section "(sandbox)")  ;{{{2

(test* "It should be compiled properly."
       "sandbox edit\n"
       (compile-statement '(sandbox (edit))))




(test-section "(sbfirst)")  ;{{{2

(test* "It should be compiled properly."
       "sbfirst\n"
       (compile-statement '(sbfirst)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(sbfirst foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(sbfirst!)))




(test-section "(sblast)")  ;{{{2

(test* "It should be compiled properly."
       "sblast\n"
       (compile-statement '(sblast)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(sblast foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(sblast!)))




(test-section "(sbrewind)")  ;{{{2

(test* "It should be compiled properly."
       "sbrewind\n"
       (compile-statement '(sbrewind)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(sbrewind foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(sbrewind!)))




(test-section "(scriptnames)")  ;{{{2

(test* "It should be compiled properly."
       "scriptnames\n"
       (compile-statement '(scriptnames)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(scriptnames foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(scriptnames!)))




(test-section "(set)")  ;{{{2

(test* "It should be compiled properly."
       '("set\n"
         "set all\n"
         "set termcap\n"
         "set wrap?\n"
         "set wrap\n"
         "set nowrap\n"
         "set wrap!\n"
         "set invwrap\n"
         "set wrap&\n"
         "set wrap&vi\n"
         "set wrap&vim\n"
         "set all&\n"
         "set wrap<\n")
       (map compile-statement
            '((set)
              (set all)
              (set termcap)
              (set wrap?)
              (set wrap)
              (set nowrap)
              (set wrap!)
              (set invwrap)
              (set wrap&)
              (set wrap&vi)
              (set wrap&vim)
              (set all&)
              (set wrap<))))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(set x y)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(set!)))




(test-section "(setglobal)")  ;{{{2

(test* "It should be compiled properly."
       '("setglobal\n"
         "setglobal all\n"
         "setglobal termcap\n"
         "setglobal wrap?\n"
         "setglobal wrap\n"
         "setglobal nowrap\n"
         "setglobal wrap!\n"
         "setglobal invwrap\n"
         "setglobal wrap&\n"
         "setglobal wrap&vi\n"
         "setglobal wrap&vim\n"
         "setglobal all&\n"
         "setglobal wrap<\n")
       (map compile-statement
            '((setglobal)
              (setglobal all)
              (setglobal termcap)
              (setglobal wrap?)
              (setglobal wrap)
              (setglobal nowrap)
              (setglobal wrap!)
              (setglobal invwrap)
              (setglobal wrap&)
              (setglobal wrap&vi)
              (setglobal wrap&vim)
              (setglobal all&)
              (setglobal wrap<))))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(setglobal x y)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(set!)))




(test-section "(setlocal)")  ;{{{2

(test* "It should be compiled properly."
       '("setlocal\n"
         "setlocal all\n"
         "setlocal termcap\n"
         "setlocal wrap?\n"
         "setlocal wrap\n"
         "setlocal nowrap\n"
         "setlocal wrap!\n"
         "setlocal invwrap\n"
         "setlocal wrap&\n"
         "setlocal wrap&vi\n"
         "setlocal wrap&vim\n"
         "setlocal all&\n"
         "setlocal wrap<\n")
       (map compile-statement
            '((setlocal)
              (setlocal all)
              (setlocal termcap)
              (setlocal wrap?)
              (setlocal wrap)
              (setlocal nowrap)
              (setlocal wrap!)
              (setlocal invwrap)
              (setlocal wrap&)
              (setlocal wrap&vi)
              (setlocal wrap&vim)
              (setlocal all&)
              (setlocal wrap<))))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(setlocal x y)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(set!)))




(test-section "(shell)")  ;{{{2

(test* "It should be compiled properly."
       "shell\n"
       (compile-statement '(shell)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(shell foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(shell!)))




(test-section "(silent)")  ;{{{2

(test* "It should be compiled properly."
       "silent edit\n"
       (compile-statement '(silent (edit))))




(test-section "(spelldump)")  ;{{{2

(test* "It should be compiled properly."
       "spelldump\n"
       (compile-statement '(spelldump)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(spelldump foo)))

(test* "It should be compiled properly with bang."
       "spelldump!\n"
       (compile-statement '(spelldump!)))




(test-section "(spellinfo)")  ;{{{2

(test* "It should be compiled properly."
       "spellinfo\n"
       (compile-statement '(spellinfo)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(spellinfo foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(spellinfo!)))




(test-section "(spellrepall)")  ;{{{2

(test* "It should be compiled properly."
       "spellrepall\n"
       (compile-statement '(spellrepall)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(spellrepall foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(spellrepall!)))




(test-section "(startgreplace)")  ;{{{2

(test* "It should be compiled properly."
       "startgreplace\n"
       (compile-statement '(startgreplace)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(startgreplace foo)))

(test* "It should be compiled properly with bang."
       "startgreplace!\n"
       (compile-statement '(startgreplace!)))




(test-section "(startinsert)")  ;{{{2

(test* "It should be compiled properly."
       "startinsert\n"
       (compile-statement '(startinsert)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(startinsert foo)))

(test* "It should be compiled properly with bang."
       "startinsert!\n"
       (compile-statement '(startinsert!)))




(test-section "(startreplace)")  ;{{{2

(test* "It should be compiled properly."
       "startreplace\n"
       (compile-statement '(startreplace)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(startreplace foo)))

(test* "It should be compiled properly with bang."
       "startreplace!\n"
       (compile-statement '(startreplace!)))




(test-section "(stop)")  ;{{{2

(test* "It should be compiled properly."
       "stop\n"
       (compile-statement '(stop)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(stop foo)))

(test* "It should be compiled properly with bang."
       "stop!\n"
       (compile-statement '(stop!)))




(test-section "(stopinsert)")  ;{{{2

(test* "It should be compiled properly."
       "stopinsert\n"
       (compile-statement '(stopinsert)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(stopinsert foo)))

(test* "It should be compiled properly with bang."
       "stopinsert!\n"
       (compile-statement '(stopinsert!)))




(test-section "(suspend)")  ;{{{2

(test* "It should be compiled properly."
       "suspend\n"
       (compile-statement '(suspend)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(suspend foo)))

(test* "It should be compiled properly with bang."
       "suspend!\n"
       (compile-statement '(suspend!)))




(test-section "(swapname)")  ;{{{2

(test* "It should be compiled properly."
       "swapname\n"
       (compile-statement '(swapname)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(swapname foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(swapname!)))




(test-section "(syncbind)")  ;{{{2

(test* "It should be compiled properly."
       "syncbind\n"
       (compile-statement '(syncbind)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(syncbind foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(syncbind!)))




(test-section "(tab)")  ;{{{2

(test* "It should be compiled properly."
       "tab edit\n"
       (compile-statement '(tab (edit))))




(test-section "(tabfirst)")  ;{{{2

(test* "It should be compiled properly."
       "tabfirst\n"
       (compile-statement '(tabfirst)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(tabfirst foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(tabfirst!)))




(test-section "(tablast)")  ;{{{2

(test* "It should be compiled properly."
       "tablast\n"
       (compile-statement '(tablast)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(tablast foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(tablast!)))




(test-section "(tabonly)")  ;{{{2

(test* "It should be compiled properly."
       "tabonly\n"
       (compile-statement '(tabonly)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(tabonly foo)))

(test* "It should be compiled properly with bang."
       "tabonly!\n"
       (compile-statement '(tabonly!)))




(test-section "(tabrewind)")  ;{{{2

(test* "It should be compiled properly."
       "tabrewind\n"
       (compile-statement '(tabrewind)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(tabrewind foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(tabrewind!)))




(test-section "(tabs)")  ;{{{2

(test* "It should be compiled properly."
       "tabs\n"
       (compile-statement '(tabs)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(tabs foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(tabs!)))




(test-section "(tags)")  ;{{{2

(test* "It should be compiled properly."
       "tags\n"
       (compile-statement '(tags)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(tags foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(tags!)))




(test-section "(tlast)")  ;{{{2

(test* "It should be compiled properly."
       "tlast\n"
       (compile-statement '(tlast)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(tlast foo)))

(test* "It should be compiled properly with bang."
       "tlast!\n"
       (compile-statement '(tlast!)))




(test-section "(topleft)")  ;{{{2

(test* "It should be compiled properly."
       "topleft edit\n"
       (compile-statement '(topleft (edit))))




(test-section "(undojoin)")  ;{{{2

(test* "It should be compiled properly."
       "undojoin\n"
       (compile-statement '(undojoin)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(undojoin foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(undojoin!)))




(test-section "(undolist)")  ;{{{2

(test* "It should be compiled properly."
       "undolist\n"
       (compile-statement '(undolist)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(undolist foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(undolist!)))




(test-section "(unsilent)")  ;{{{2

(test* "It should be compiled properly."
       "unsilent edit\n"
       (compile-statement '(unsilent (edit))))




(test-section "(verbose)")  ;{{{2

(test* "It should be compiled properly."
       "verbose edit\n"
       (compile-statement '(verbose (edit))))




(test-section "(vertical)")  ;{{{2

(test* "It should be compiled properly."
       "vertical edit\n"
       (compile-statement '(vertical (edit))))




(test-section "(view)")  ;{{{2

(test* "It should be compiled properly."
       '("view\n"
         "view `='ordinary-path'`\n"
         "view `='path with spaces'`\n"
         "view `='path''with\\strange`characters'`\n"
         "view #\n"
         "view #3\n"
         "view `=(\"foo\" . \"bar\")`\n"
         "view `find . -name ver\\\\*.c -print`\n"
         "view ++encoding=utf-8 ++fileformat=unix `='foo'`\n")
       (map compile-statement
            '((view)
              (view "ordinary-path")
              (view "path with spaces")
              (view "path'with\\strange`characters")
              (view (:alternate))
              (view (:buffer 3))
              (view (:expression (.. "foo" "bar")))
              (view (:command "find . -name ver\\*.c -print"))
              (view "foo" :encoding "utf-8" :fileformat "unix"))))

(test* "It should fail for invalid form."
       (test-error <error>)
       (compile-statement '(view foo bar)))




(test-section "(view!)")  ;{{{2

(test* "It should be compiled properly."
       '("view!\n"
         "view! `='ordinary-path'`\n"
         "view! `='path with spaces'`\n"
         "view! `='path''with\\strange`characters'`\n"
         "view! #\n"
         "view! #3\n"
         "view! `=(\"foo\" . \"bar\")`\n"
         "view! `find . -name ver\\\\*.c -print`\n"
         "view! ++encoding=utf-8 ++fileformat=unix `='foo'`\n")
       (map compile-statement
            '((view!)
              (view! "ordinary-path")
              (view! "path with spaces")
              (view! "path'with\\strange`characters")
              (view! (:alternate))
              (view! (:buffer 3))
              (view! (:expression (.. "foo" "bar")))
              (view! (:command "find . -name ver\\*.c -print"))
              (view! "foo" :encoding "utf-8" :fileformat "unix"))))

(test* "It should fail for invalid form."
       (test-error <error>)
       (compile-statement '(view! foo bar)))




(test-section "(visual)")  ;{{{2

(test* "It should be compiled properly."
       '("visual\n"
         "visual `='ordinary-path'`\n"
         "visual `='path with spaces'`\n"
         "visual `='path''with\\strange`characters'`\n"
         "visual #\n"
         "visual #3\n"
         "visual `=(\"foo\" . \"bar\")`\n"
         "visual `find . -name ver\\\\*.c -print`\n"
         "visual ++encoding=utf-8 ++fileformat=unix `='foo'`\n")
       (map compile-statement
            '((visual)
              (visual "ordinary-path")
              (visual "path with spaces")
              (visual "path'with\\strange`characters")
              (visual (:alternate))
              (visual (:buffer 3))
              (visual (:expression (.. "foo" "bar")))
              (visual (:command "find . -name ver\\*.c -print"))
              (visual "foo" :encoding "utf-8" :fileformat "unix"))))

(test* "It should fail for invalid form."
       (test-error <error>)
       (compile-statement '(visual foo bar)))




(test-section "(visual!)")  ;{{{2

(test* "It should be compiled properly."
       '("visual!\n"
         "visual! `='ordinary-path'`\n"
         "visual! `='path with spaces'`\n"
         "visual! `='path''with\\strange`characters'`\n"
         "visual! #\n"
         "visual! #3\n"
         "visual! `=(\"foo\" . \"bar\")`\n"
         "visual! `find . -name ver\\\\*.c -print`\n"
         "visual! ++encoding=utf-8 ++fileformat=unix `='foo'`\n")
       (map compile-statement
            '((visual!)
              (visual! "ordinary-path")
              (visual! "path with spaces")
              (visual! "path'with\\strange`characters")
              (visual! (:alternate))
              (visual! (:buffer 3))
              (visual! (:expression (.. "foo" "bar")))
              (visual! (:command "find . -name ver\\*.c -print"))
              (visual! "foo" :encoding "utf-8" :fileformat "unix"))))

(test* "It should fail for invalid form."
       (test-error <error>)
       (compile-statement '(visual! foo bar)))




(test-section "(viusage)")  ;{{{2

(test* "It should be compiled properly."
       "viusage\n"
       (compile-statement '(viusage)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(viusage foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(viusage!)))




(test-section "(wall)")  ;{{{2

(test* "It should be compiled properly."
       "wall\n"
       (compile-statement '(wall)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(wall foo)))

(test* "It should be compiled properly with bang."
       "wall!\n"
       (compile-statement '(wall!)))




(test-section "(X)")  ;{{{2

(test* "It should be compiled properly."
       "X\n"
       (compile-statement '(X)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(X foo)))

(test* "It should fail if bang is given."
       (test-error <error>)
       (compile-statement '(X!)))




(test-section "(xall)")  ;{{{2

(test* "It should be compiled properly."
       "xall\n"
       (compile-statement '(xall)))

(test* "It should fail if extra argument is given."
       (test-error <error>)
       (compile-statement '(xall foo)))

(test* "It should be compiled properly with bang."
       "xall!\n"
       (compile-statement '(xall!)))




;(test-section "template")  ;{{{1

;(test* "title"
;       expected-value
;       test-expression)




(test-end)  ;{{{1




; __END__
; vim: filetype=scheme foldmethod=marker
