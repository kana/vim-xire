#!/usr/bin/env gosh
; xirec - Xire-script-to-Vim-script compiler
; Version: @@VERSION@@
; Copyright (C) 2009-2010 kana <http://whileimautomaton.net/>
; License: So-called MIT/X license  {{{
;     Permission is hereby granted, free of charge, to any person obtaining
;     a copy of this software and associated documentation files (the
;     "Software"), to deal in the Software without restriction, including
;     without limitation the rights to use, copy, modify, merge, publish,
;     distribute, sublicense, and/or sell copies of the Software, and to
;     permit persons to whom the Software is furnished to do so, subject to
;     the following conditions:
;
;     The above copyright notice and this permission notice shall be included
;     in all copies or substantial portions of the Software.
;
;     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
;     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
;     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
;     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
;     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
;     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
; }}}

(use gauche.parameter)
(use text.tree)
(use util.list)
(use util.match)




;;; Environment
;;; ============

;; Represent an environment for xire compilation.
(define-class <xire-environment> ()
  ([macros  ; contain xire macro bindings.
     :init-keyword :macros
     :init-form (make-hash-table 'eq?)]))

;; Represent the current environment for xire compilation.
(define xire-environment
  (make-parameter (make <xire-environment>)))

;; Copy the current xire environment.
(define (xire-environment-copy :optional (environment (xire-environment)))
  (make <xire-environment>
        :macros (hash-table-copy (ref environment 'macros))))




;;; Context
;;; =======

;; Represent the context to compile a xire script.  The difference between
;; <xire-context> and <xire-environment> is that:
;;
;; - <xire-environment> holds global information such as xire macro bindings.
;; - While <xire-context> holds local information, for example, whether a xire
;;   script being compiled is a top-level statement or not.
(define-class <xire-context> ()
  ([type  ; The type of a form being compiled -- statement, expression, etc.
     :init-keyword :type]))

(define (make-statement-context context)
  (make <xire-context> :type 'statement))
(define (make-expression-context context)
  (make <xire-context> :type 'expression))

(define (statement-context? context)
  (eq? (ref context 'type) 'statement))
(define (expression-context? context)
  (eq? (ref context 'type) 'expression))

(define (ensure-statement-context form context)
  (unless (statement-context? context)
    (error "Invalid form in a statement context:" form)))
(define (ensure-expression-context form context)
  (unless (expression-context? context)
    (error "Invalid form in an expression context:" form)))




;;; Xire macros
;;; ===========
;;;
;;; Conventions
;;; -----------
;;;
;;; For procedures in this section,
;;;
;;; - Argument called NAME is a symbol.
;;; - Argument called EXPANDER is a procedure which takes two arguments,
;;;   the form to expand and the context to compile the form.

;; Look up a xire macro with the NAME.
(define (xire-lookup-macro name :optional (environment (xire-environment)))
  (hash-table-get (ref environment 'macros) name #f))

;; Register a xire macro EXPANDER with the NAME into the current CONTEXT.
(define (xire-register-macro! name expander
                              :optional (environment (xire-environment)))
  (hash-table-put! (ref environment 'macros) name expander))

;; Define new xire macro in the current environment.
;; This is just a syntax sugar for xire-register-macro!.
(define-syntax define-xire-macro
  (syntax-rules ()
    [(_ (name form context) . body)
     (xire-register-macro! 'name (lambda (form context) . body))]))

;; Define new xire statement in the current environment.
;; This is a wrapper for define-xire-macro.
(define-syntax define-xire-statement
  (syntax-rules ()
    [(_ name [pattern . body] ...)
     (define-xire-macro (name form context)
       (ensure-statement-context form context)
       (let1 clauses (cdr form)
         (match clauses
           [pattern . body]
           ...)))]))

;; Define new xire expression in the current environment.
;; This is a wrapper for define-xire-macro.
(define-syntax define-xire-expression
  (syntax-rules ()
    [(_ "internal" name context [pattern . body] ...)
     (define-xire-macro (name form context)
       (ensure-expression-context form context)
       (let1 clauses (cdr form)
         (match clauses
           [pattern . body]
           ...)))]
    ; Entry
    [(_ name [pattern . body] ...)  ; Basic form.
     (define-xire-expression name context [pattern . body] ...)]
    [(_ name context [pattern . body] ...)  ; With the name of context.
     (define-xire-expression "internal" name context [pattern . body] ...)]))




;;; Compiler
;;; ========

;; Translate xire script into Vim script.
;; Xire script is read from INP and resulting Vim script is written into OUTP.
(define (xire-translate inp outp
                        :key (environment (xire-environment-copy))
                             (scheme-environment (make-module #f)))
  (define compiled-vim-script-tree (list))
  (define (finish)
    (write-tree (reverse compiled-vim-script-tree) outp))
  (define context (make <xire-context>))

  (eval '(extend user) scheme-environment)
  (parameterize ([xire-environment environment])
    (let loop ()
      (match (read inp)
        [(? eof-object?)
         (finish)]
        [(and ((or 'define-xire-macro)
               . _)
              form)
         (eval form scheme-environment)
         (loop)]
        [(and (name . _) form)
         (if (xire-lookup-macro name)
           (push! compiled-vim-script-tree (xire-compile form context))
           (eval form scheme-environment))
         (loop)]))))

;; Compile a xire script FORM then return a resulting Vim script.
;; Resulting Vim script is expressed as a list of strings which can be passed
;; to write-tree provided by text.tree.
(define (xire-compile form context)
  (define (report-syntax-error)
    (errorf "Invalid xire form: ~s" form))
  (match form
    [((? symbol? name) . args)
     (cond
       [(xire-lookup-macro name)
        => (lambda (expander)
             (expander form context))]
       [else
         (report-syntax-error)])]
    [(or (? number?) (? string?) (? symbol?))
     (ensure-expression-context form context)
     (x->vim-script-notation form)]
    ; FIXME: Add more support for Vim script expressions.
    [_
      (report-syntax-error)]))

;; Convert a given Scheme OBJECT into a string which represents
;; a corresponding Vim script object.
;;
;; FIXME: Add conversion for List, Dictionary and Funcref.
(define (x->vim-script-notation object)
  (cond
    [(number? object)  ; FIXME: Consider non-integers and big integers.
     (number->string object)]
    [(string? object)  ; FIXME: Escape special characters properly.
     (format "~s" object)]
    [(symbol? object)  ; Vim script variable
     (symbol->string object)]  ; FIXME: Convert "->" to "_to_", etc.
    [else
      (errorf "Invalid object for Vim script: ~s" object)]))




;;; Built-in xire macros
;;; ====================

(define-xire-macro (comment form context)
  (ensure-statement-context form context)
  (match form
    [(_ (? string? comment-string) ...)
     `("\""
       ,(fold-right (lambda (l r) `(" " ,l . ,r))
                   '()
                   comment-string)
       "\n")]))

;;; Expressions
;;; -----------
;;;
;;; See also :help expression-syntax .
;;;
;;; Format:
;;; Vim script syntax       Xire script syntax      Note
;;;
;;; expr1
;;; ~~~~~
;;;
;;; expr2 ? expr1 : expr1   (?: expr2 expr1 expr1)  if-then-else
;;;
;;; expr2
;;; ~~~~~
;;;
;;; expr3 || expr3 ...      (or expr3 ...)          logical OR
;;;
;;; expr3
;;; ~~~~~
;;;
;;; expr4 && expr4 ...      (and expr4 ...)         logical AND
;;;
;;; expr4
;;; ~~~~~
;;;
;;; expr5 == expr5          (== expr5 expr5)        equal
;;; expr5 != expr5          (!= expr5 expr5)        not equal
;;; expr5 >  expr5          (>  expr5 expr5)        greater than
;;; expr5 >= expr5          (>= expr5 expr5)        greater than or equal
;;; expr5 <  expr5          (<  expr5 expr5)        smaller than
;;; expr5 <= expr5          (<= expr5 expr5)        smaller than or equal
;;; expr5 =~ expr5          (=~ expr5 expr5)        regexp matches
;;; expr5 !~ expr5          (!~ expr5 expr5)        regexp doesn't match
;;;
;;; expr5 ==? expr5         (==? expr5 expr5)       equal, ignoring case
;;; expr5 ==# expr5         (==# expr5 expr5)       equal, match case
;;; etc.                    As above, append ? for ignoring case, # for
;;;                         matching case.
;;;
;;;                         NB: Gauche can read "==#" and others as valid
;;;                         symbols, but R5RS doesn't allow to use "#" in
;;;                         symbols.
;;;
;;; expr5 is expr5          (is expr5 expr5)        same instance
;;; expr5 isnot expr5       (isnot expr5 expr5)     different instance
;;;
;;; expr5
;;; ~~~~~
;;;
;;; expr6 +  expr6 ...      (+ expr6 ...)           number addition
;;;                                                 or list concatenation
;;; expr6 -  expr6 ...      (- expr6 ...)           number subtraction
;;; expr6 .  expr6 ...      (.. expr6 ...)          string concatenation
;;;                                                 (borrowed from Lua's one)
;;;
;;;                         NB: Gauche can read ".." as a valid symbol, but
;;;                         R5RS doesn't allow such symbol.
;;;
;;; expr6
;;; ~~~~~
;;;
;;; expr7 *  expr7 ...      (* expr7 ...)           number multiplication
;;; expr7 /  expr7 ...      (/ expr7 ...)           number division
;;; expr7 %  expr7 ...      (% expr7 ...)           number modulo
;;;
;;; expr7
;;; ~~~~~
;;;
;;; ! expr7                 (! expr7)               logical NOT
;;; - expr7                 N/A                     unary minus
;;; + expr7                 N/A                     unary plus
;;;
;;;                         NB: xire provides n-ary +/- operators
;;;                         and they also serve as unary ones.
;;;
;;; expr8
;;; ~~~~~
;;;
;;; expr8[expr1]            (ref expr8 expr1)       Reference an element in
;;;                                                 string, list or dictionary
;;; expr8[expr1 : expr1]    (slice expr8 expr1 expr1)
;;;                                                 Slice string or list
;;; expr8.name              N/A (ref expr8 "name")  Dictionary reference
;;; expr8(expr1, ...)       (call expr8 expr1 ...)  function call with Funcref
;;;
;;; expr9
;;; ~~~~~
;;;
;;; number                  Scheme number           number constant
;;; "string"                Scheme string           string with \-notation
;;; 'string'                N/A                     literal string
;;; [expr1, ...]            (list expr1 ...)        list
;;; {expr1: expr1, ...}     (dict expr1 expr1 ...)  dictionary
;;; &option                 (& "option")            option value
;;; (expr1)                 N/A                     nested expression
;;; variable                Scheme symbol           variable reference
;;; va{ria}ble              N/A [*]                 ... with curly braces
;;; $VAR                    ($ "VAR") [*]           environment variable
;;; @r                      (@ "r") [*]             contents of register 'r'
;;; function(expr1, ...)    (function expr1 ...)    function call
;;;                         via macros defined separately.
;;; func{ti}on(expr1, ...)  N/A [*]                 ... with curly braces
;;;
;;;                         [*] ... FIXME: Need review.
;;;
;;;                         Number, string and variable reference are handled
;;;                         by x->vim-script-notation and xire-compile .
;;;
;;; [*SPACES] It's necessary to add spaces around operators to avoid wrong
;;;     compilation result.  For example, think about compiling the following
;;;     script:
;;;
;;;         (?: 'r 's 't)
;;;
;;;     If there is wrapping spaces, resulting Vim script will be:
;;;
;;;         (r ? s : t)
;;;
;;;     If there is no wrapping spaces, resulting Vim script will be:
;;;
;;;         (r?s:t)
;;;
;;;     And the latter result is ambiguous, because "s:t" may be treated as
;;;     a script-local variable named "t" instead of local variables "s" and
;;;     "t".  There are many problems similar to this one.

(define (%compile-nary-operator-exression forms vim-script-operator context)
  `("("
    ,@(intersperse `(" " ,vim-script-operator " ")
                   (map (cut xire-compile <> context) forms))
    ")"))

(define-syntax define-nary-operator
  (syntax-rules ()
    [(_ name vim-script-operator)  ; 2 <= N
     (define-xire-expression name context
       [(valueN ..2)
        (%compile-nary-operator-exression
          valueN
          vim-script-operator
          context)])]
    [(_ name vim-script-operator initial-value)  ; 1 <= N
     (define-xire-expression name context
       [(value1)
        (xire-compile `(name initial-value ,value1) context)]
       [(valueN ..2)
        (%compile-nary-operator-exression
          valueN
          vim-script-operator
          context)])]))

(define-syntax define-binary-operator
  (syntax-rules ()
    [(_ name vim-script-operator)
     (define-xire-expression name context
       [(l r)
        (list "("
              (xire-compile l context)
              " "  ; [*SPACES] to avoid (is v e) ==> (vise)
              vim-script-operator
              " "
              (xire-compile r context)
              ")")])]))

(define-xire-expression ?: context
  [(expression then-part else-part)
   (list "("
         (xire-compile expression context)
         " ? "
         (xire-compile then-part context)
         " : "  ; [*SPACES] to avoid (?: 'r 's 't) ==> (r?s:t)
         (xire-compile else-part context)
         ")")])

(define-nary-operator or "||")

(define-nary-operator and "&&")

(define-binary-operator != "!=")
(define-binary-operator !=# "!=#")
(define-binary-operator !=? "!=?")
(define-binary-operator !~ "!~")
(define-binary-operator !~# "!~#")
(define-binary-operator !~? "!~?")
(define-binary-operator < "<")
(define-binary-operator <# "<#")
(define-binary-operator <= "<=")
(define-binary-operator <=# "<=#")
(define-binary-operator <=? "<=?")
(define-binary-operator <? "<?")
(define-binary-operator == "==")
(define-binary-operator ==# "==#")
(define-binary-operator ==? "==?")
(define-binary-operator =~ "=~")
(define-binary-operator =~# "=~#")
(define-binary-operator =~? "=~?")
(define-binary-operator > ">")
(define-binary-operator ># ">#")
(define-binary-operator >= ">=")
(define-binary-operator >=# ">=#")
(define-binary-operator >=? ">=?")
(define-binary-operator >? ">?")
(define-binary-operator is "is")
(define-binary-operator is# "is#")
(define-binary-operator is? "is?")
(define-binary-operator isnot "isnot")
(define-binary-operator isnot# "isnot#")
(define-binary-operator isnot? "isnot?")

(define-nary-operator + "+" 0)
(define-nary-operator - "-" 0)
(define-nary-operator .. ".")

(define-nary-operator * "*")
(define-nary-operator / "/")
(define-nary-operator % "%")

(define-xire-expression not context
  [(expression)
   (list "("
         "!"
         (xire-compile expression context)
         ")")])
; unary +/- operators are provided as a part of n-ary +/- operators.

(define-xire-expression ref context
  [(container-expression index-expression)
   (list "("
         "("
         (xire-compile container-expression context)
         ")"
         "["
         "("  ; To clear ambiguoussness -- a[l:r] = a[(l:r)] or a[(l):(r)]?
         (xire-compile index-expression context)
         ")"
         "]"
         ")")])
(define-xire-expression slice context
  [(container-expression index1-expression index2-expression)
   (list "("
         "("
         (xire-compile container-expression context)
         ")"
         "["
         "("
         (xire-compile index1-expression context)
         ")"
         ":"
         "("
         (xire-compile index2-expression context)
         ")"
         "]"
         ")")])




;;; Main
;;; ====

(define (main args)
  ; FIXME: NIY
  0)




; __END__  {{{1
; vim: filetype=scheme foldmethod=marker
