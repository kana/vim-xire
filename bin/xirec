#!/usr/bin/env gosh
; xirec - Xire-script-to-Vim-script compiler
; Version: @@VERSION@@
; Copyright (C) 2009-2010 kana <http://whileimautomaton.net/>
; License: So-called MIT/X license  {{{
;     Permission is hereby granted, free of charge, to any person obtaining
;     a copy of this software and associated documentation files (the
;     "Software"), to deal in the Software without restriction, including
;     without limitation the rights to use, copy, modify, merge, publish,
;     distribute, sublicense, and/or sell copies of the Software, and to
;     permit persons to whom the Software is furnished to do so, subject to
;     the following conditions:
;
;     The above copyright notice and this permission notice shall be included
;     in all copies or substantial portions of the Software.
;
;     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
;     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
;     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
;     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
;     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
;     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
; }}}

(use gauche.parameter)
(use text.tree)
(use util.match)




;;; Environment
;;; ============

;; Represent an environment for xire compilation.
(define-class <xire-environment> ()
  ([macros  ; contain xire macro bindings.
     :init-keyword :macros
     :init-form (make-hash-table 'eq?)]))

;; Represent the current environment for xire compilation.
(define xire-environment
  (make-parameter (make <xire-environment>)))

;; Copy the current xire environment.
(define (xire-environment-copy :optional (environment (xire-environment)))
  (make <xire-environment>
        :macros (hash-table-copy (ref environment 'macros))))




;;; Context
;;; =======

;; Represent the context to compile a xire script.  The difference between
;; <xire-context> and <xire-environment> is that:
;;
;; - <xire-environment> holds global information such as xire macro bindings.
;; - While <xire-context> holds local information, for example, whether a xire
;;   script being compiled is a top-level statement or not.
(define-class <xire-context> ()
  ([type  ; The type of a form being compiled -- statement, expression, etc.
     :init-keyword :type]))

(define (make-statement-context context)
  (make <xire-context> :type 'statement))
(define (make-expression-context context)
  (make <xire-context> :type 'expression))

(define (statement-context? context)
  (eq? (ref context 'type) 'statement))
(define (expression-context? context)
  (eq? (ref context 'type) 'expression))

(define (ensure-statement-context form context)
  (unless (statement-context? context)
    (error "Invalid form in a statement context:" form)))
(define (ensure-expression-context form context)
  (unless (expression-context? context)
    (error "Invalid form in an expression context:" form)))




;;; Xire macros
;;; ===========
;;;
;;; Conventions
;;; -----------
;;;
;;; For procedures in this section,
;;;
;;; - Argument called NAME is a symbol.
;;; - Argument called EXPANDER is a procedure which takes two arguments,
;;;   the form to expand and the context to compile the form.

;; Look up a xire macro with the NAME.
(define (xire-lookup-macro name :optional (environment (xire-environment)))
  (hash-table-get (ref environment 'macros) name #f))

;; Register a xire macro EXPANDER with the NAME into the current CONTEXT.
(define (xire-register-macro! name expander
                              :optional (environment (xire-environment)))
  (hash-table-put! (ref environment 'macros) name expander))

;; Define new xire macro in the current environment.
;; This is just a syntax sugar for xire-register-macro!.
(define-syntax define-xire-macro
  (syntax-rules ()
    [(_ (name form context) . body)
     (xire-register-macro! 'name (lambda (form context) . body))]))

;; Define new xire statement in the current environment.
;; This is a wrapper for define-xire-macro.
(define-syntax define-xire-statement
  (syntax-rules ()
    [(_ name [pattern . body] ...)
     (define-xire-macro (name form context)
       (ensure-statement-context form context)
       (let1 clauses (cdr form)
         (match clauses
           [pattern . body]
           ...)))]))




;;; Compiler
;;; ========

;; Translate xire script into Vim script.
;; Xire script is read from INP and resulting Vim script is written into OUTP.
(define (xire-translate inp outp
                        :key (environment (xire-environment-copy))
                             (scheme-environment (make-module #f)))
  (define compiled-vim-script-tree (list))
  (define (finish)
    (write-tree (reverse compiled-vim-script-tree) outp))
  (define context (make <xire-context>))

  (eval '(extend user) scheme-environment)
  (parameterize ([xire-environment environment])
    (let loop ()
      (match (read inp)
        [(? eof-object?)
         (finish)]
        [(and ((or 'define-xire-macro)
               . _)
              form)
         (eval form scheme-environment)
         (loop)]
        [(and (name . _) form)
         (if (xire-lookup-macro name)
           (push! compiled-vim-script-tree (xire-compile form context))
           (eval form scheme-environment))
         (loop)]))))

;; Compile a xire script STATEMENT, then return a resulting Vim script.
;; Resulting Vim script is expressed as a list of strings which can be passed
;; to write-tree provided by text.tree.
(define (xire-compile statement context)
  (match-let1 (name . args) statement
    (cond
      [(xire-lookup-macro name)
       => (lambda (expander)
            (expander statement context))]
      [else
        (errorf "Invalid xire statement: ~s" statement)])))




;;; Main
;;; ====

(define (main args)
  ; FIXME: NIY
  0)




; __END__  {{{1
; vim: filetype=scheme foldmethod=marker
