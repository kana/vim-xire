#!/usr/bin/env gosh
; xirec - Xire-script-to-Vim-script compiler
; Version: @@VERSION@@
; Copyright (C) 2009-2010 kana <http://whileimautomaton.net/>
; License: So-called MIT/X license  {{{
;     Permission is hereby granted, free of charge, to any person obtaining
;     a copy of this software and associated documentation files (the
;     "Software"), to deal in the Software without restriction, including
;     without limitation the rights to use, copy, modify, merge, publish,
;     distribute, sublicense, and/or sell copies of the Software, and to
;     permit persons to whom the Software is furnished to do so, subject to
;     the following conditions:
;
;     The above copyright notice and this permission notice shall be included
;     in all copies or substantial portions of the Software.
;
;     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
;     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
;     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
;     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
;     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
;     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
; }}}

(use gauche.parameter)
(use text.tree)
(use util.list)
(use util.match)




;;; Environment
;;; ============

;; Represent an environment for xire compilation.
(define-class <xire-environment> ()
  ([macros  ; contain xire macro bindings.
     :init-keyword :macros
     :init-form (make-hash-table 'eq?)]))

;; Represent the current environment for xire compilation.
(define xire-environment
  (make-parameter (make <xire-environment>)))

;; Copy the current xire environment.
(define (xire-environment-copy :optional (environment (xire-environment)))
  (make <xire-environment>
        :macros (hash-table-copy (ref environment 'macros))))




;;; Context
;;; =======

;; Represent the context to compile a xire script.  The difference between
;; <xire-context> and <xire-environment> is that:
;;
;; - <xire-environment> holds global information such as xire macro bindings.
;; - While <xire-context> holds local information, for example, whether a xire
;;   script being compiled is a top-level statement or not.
(define-class <xire-context> ()
  ([type  ; The type of a form being compiled -- statement, expression, etc.
     :init-keyword :type]))

(define (make-statement-context context)
  (make <xire-context> :type 'statement))
(define (make-expression-context context)
  (make <xire-context> :type 'expression))

(define (statement-context? context)
  (eq? (ref context 'type) 'statement))
(define (expression-context? context)
  (eq? (ref context 'type) 'expression))

(define (ensure-statement-context form context)
  (unless (statement-context? context)
    (error "Invalid form in a statement context:" form)))
(define (ensure-expression-context form context)
  (unless (expression-context? context)
    (error "Invalid form in an expression context:" form)))




;;; Xire macros
;;; ===========
;;;
;;; Conventions
;;; -----------
;;;
;;; For procedures in this section,
;;;
;;; - Argument called NAME is a symbol.
;;; - Argument called EXPANDER is a procedure which takes two arguments,
;;;   the form to expand and the context to compile the form.

;; Look up a xire macro with the NAME.
(define (xire-lookup-macro name :optional (environment (xire-environment)))
  (hash-table-get (ref environment 'macros) name #f))

;; Register a xire macro EXPANDER with the NAME into the current CONTEXT.
(define (xire-register-macro! name expander
                              :optional (environment (xire-environment)))
  (hash-table-put! (ref environment 'macros) name expander))

;; Define new xire macro in the current environment.
;; This is just a syntax sugar for xire-register-macro!.
(define-syntax define-xire-macro
  (syntax-rules ()
    [(_ (name form context) . body)
     (xire-register-macro! 'name (lambda (form context) . body))]))

;; Define new xire statement in the current environment.
;; This is a wrapper for define-xire-macro.
(define-syntax define-xire-statement
  (syntax-rules ()
    [(_ "internal" name context [pattern . body] ...)
     (define-xire-macro (name form context)
       (ensure-statement-context form context)
       (let1 clauses (cdr form)
         (match clauses
           [pattern . body]
           ...)))]
    ; Entry
    [(_ name [pattern . body] ...)  ; Basic form.
     (define-xire-statement name context [pattern . body] ...)]
    [(_ name statement)  ; For a simple statement such as :break.
     (define-xire-statement name context [() '(statement "\n")])]
    [(_ name context [pattern . body] ...)  ; With the name of context.
     (define-xire-statement "internal" name context [pattern . body] ...)]))

;; Define new xire expression in the current environment.
;; This is a wrapper for define-xire-macro.
(define-syntax define-xire-expression
  (syntax-rules ()
    [(_ "internal" name context [pattern . body] ...)
     (define-xire-macro (name form context)
       (ensure-expression-context form context)
       (let1 clauses (cdr form)
         (match clauses
           [pattern . body]
           ...)))]
    ; Entry
    [(_ name [pattern . body] ...)  ; Basic form.
     (define-xire-expression name context [pattern . body] ...)]
    [(_ name context [pattern . body] ...)  ; With the name of context.
     (define-xire-expression "internal" name context [pattern . body] ...)]))




;;; Compiler
;;; ========

;; Translate xire script into Vim script.
;; Xire script is read from INP and resulting Vim script is written into OUTP.
(define (xire-translate inp outp
                        :key (environment (xire-environment-copy))
                             (scheme-environment (make-module #f)))
  (define compiled-vim-script-tree (list))
  (define (finish)
    (write-tree (reverse compiled-vim-script-tree) outp))
  (define context (make <xire-context>))

  (eval '(extend user) scheme-environment)
  (parameterize ([xire-environment environment])
    (let loop ()
      (match (read inp)
        [(? eof-object?)
         (finish)]
        [(and ((or 'define-xire-macro)
               . _)
              form)
         (eval form scheme-environment)
         (loop)]
        [(and (name . _) form)
         (if (xire-lookup-macro name)
           (push! compiled-vim-script-tree (xire-compile form context))
           (eval form scheme-environment))
         (loop)]))))

;; Compile a xire script FORM then return a resulting Vim script.
;; Resulting Vim script is expressed as a list of strings which can be passed
;; to write-tree provided by text.tree.
(define (xire-compile form context)
  (define (report-syntax-error)
    (errorf "Invalid xire form: ~s" form))
  (match form
    [((? symbol? name) . args)
     (cond
       [(xire-lookup-macro name)
        => (lambda (expander)
             (expander form context))]
       [else
         (report-syntax-error)])]
    [_
     (cond
       [(x->vim-script-notation form #f)
        => (lambda (vim-script-notation)
             (ensure-expression-context form context)
             vim-script-notation)]
       [else
         (report-syntax-error)])]))

;; Convert a given Scheme OBJECT into a string which represents
;; a corresponding Vim script object.
(define (x->vim-script-notation object :optional (raise-error-p #t))
  ; Vim script numbers are 32 bit signed integers.  (cf. :help Number)
  (define MINIMAL-NUMBER (ash -1 31))
  (define MAXIMUM-NUMBER (- (ash 1 31) 1))

  (cond
    [(number? object)
     (cond
       [(< object MINIMAL-NUMBER)
        (errorf "Too small number for Vim script: ~s" object)]
       [(< MAXIMUM-NUMBER object)
        (errorf "Too big number for Vim script: ~s" object)]
       [(integer? object)
        (number->string (inexact->exact object))]
       ; FIXME: Support float in Vim script.
       [else
        (errorf "Invalid number for Vim script: ~s" object)])]
    [(string? object)
     (string->vim-script-string-notation object)]
    [(symbol? object)  ; Vim script variable
     (convert-identifier-conventions (symbol->string object))]
    [(regexp? object)
     (regexp-replace-all* (regexp->string object)
                          #/'/ "''"
                          #/^(.*)$/ "'\\1'")]
    ; List literal is provided by a xire macro.
    ; Dictionary literal is provided by a xire macro.
    ; FIXME: How about Funcref?
    [else
      (if raise-error-p
        (errorf "Invalid object for Vim script: ~s" object)
        #f)]))

;; Convert Scheme string object into Vim script string notation.
;;
;; FIXME: Escape special characters properly.
(define (string->vim-script-string-notation s)
  (format "~s" s))

;; Convert identifier conventions between Scheme and Vim script.  For example,
;; Scheme usually uses hyphen (-) to join words in an identifier, while Vim
;; script uses underscore (_) for that purpose.  This procedure converts such
;; conventions.
(define (convert-identifier-conventions scheme-identifier)
  ; FIXME: Raise error for invalid characters as Vim script identifier.
  (regexp-replace-all* scheme-identifier
                       #/\?$/ "_p"
                       #/!$/ "_x"
                       #/->/ "_to_"
                       #/-/ "_"))




;;; Built-in xire macros
;;; ====================

;;; Primitives
;;; ----------

(define-xire-macro (RAW form context)
  ; Embed raw Vim script.  This is a temporary stuff until xire supports full
  ; features of Vim script.  Use it carefully and it should not be used if
  ; possible.
  (match form
    [(_ . stuffs)
     (map x->string stuffs)]))

(define-xire-statement comment
  [((? string? comment-string) ...)
   `("\""
     ,(string-join comment-string " " 'prefix)
     "\n")])


;;; Expressions
;;; -----------
;;;
;;; See also :help expression-syntax .
;;;
;;; Format:
;;; Vim script syntax       Xire script syntax      Note
;;;
;;; expr1
;;; ~~~~~
;;;
;;; expr2 ? expr1 : expr1   (?: expr2 expr1 expr1)  if-then-else
;;;
;;; expr2
;;; ~~~~~
;;;
;;; expr3 || expr3 ...      (or expr3 ...)          logical OR
;;;
;;; expr3
;;; ~~~~~
;;;
;;; expr4 && expr4 ...      (and expr4 ...)         logical AND
;;;
;;; expr4
;;; ~~~~~
;;;
;;; expr5 == expr5          (== expr5 expr5)        equal
;;; expr5 != expr5          (!= expr5 expr5)        not equal
;;; expr5 >  expr5          (>  expr5 expr5)        greater than
;;; expr5 >= expr5          (>= expr5 expr5)        greater than or equal
;;; expr5 <  expr5          (<  expr5 expr5)        smaller than
;;; expr5 <= expr5          (<= expr5 expr5)        smaller than or equal
;;; expr5 =~ expr5          (=~ expr5 expr5)        regexp matches
;;; expr5 !~ expr5          (!~ expr5 expr5)        regexp doesn't match
;;;
;;; expr5 ==? expr5         (==? expr5 expr5)       equal, ignoring case
;;; expr5 ==# expr5         (==# expr5 expr5)       equal, match case
;;; etc.                    As above, append ? for ignoring case, # for
;;;                         matching case.
;;;
;;;                         NB: Gauche can read "==#" and others as valid
;;;                         symbols, but R5RS doesn't allow to use "#" in
;;;                         symbols.
;;;
;;; expr5 is expr5          (is expr5 expr5)        same instance
;;; expr5 isnot expr5       (isnot expr5 expr5)     different instance
;;;
;;; expr5
;;; ~~~~~
;;;
;;; expr6 +  expr6 ...      (+ expr6 ...)           number addition
;;;                                                 or list concatenation
;;; expr6 -  expr6 ...      (- expr6 ...)           number subtraction
;;; expr6 .  expr6 ...      (.. expr6 ...)          string concatenation
;;;                                                 (borrowed from Lua's one)
;;;
;;;                         NB: Gauche can read ".." as a valid symbol, but
;;;                         R5RS doesn't allow such symbol.
;;;
;;; expr6
;;; ~~~~~
;;;
;;; expr7 *  expr7 ...      (* expr7 ...)           number multiplication
;;; expr7 /  expr7 ...      (/ expr7 ...)           number division
;;; expr7 %  expr7 ...      (% expr7 ...)           number modulo
;;;
;;; expr7
;;; ~~~~~
;;;
;;; ! expr7                 (! expr7)               logical NOT
;;; - expr7                 N/A                     unary minus
;;; + expr7                 N/A                     unary plus
;;;
;;;                         NB: xire provides n-ary +/- operators
;;;                         and they also serve as unary ones.
;;;
;;; expr8
;;; ~~~~~
;;;
;;; expr8[expr1]            (ref expr8 expr1)       Reference an element in
;;;                                                 string, list or dictionary
;;; expr8[expr1 : expr1]    (slice expr8 expr1 expr1)
;;;                                                 Slice string or list
;;; expr8.name              (-> expr8 name)         Dictionary reference
;;; expr8(expr1, ...)       (apply expr8 expr1 ...) function call with Funcref
;;;
;;;                         NB: Gauche can read "->" as a valid symbol, but
;;;                         R5RS doesn't allow such symbol.
;;;
;;;                         FIXME: Need review - :call, call(), funcref().
;;;
;;; expr9
;;; ~~~~~
;;;
;;; number                  Scheme number           number constant
;;; "string"                Scheme string           string with \-notation
;;; 'string'                N/A                     literal string
;;; [expr1, ...]            (list expr1 ...)        list
;;; {expr1: expr1, ...}     (dict (key value) ...)  dictionary
;;; &option                 (& "option")            option value
;;; &option                 (& option)              option value
;;; &l:option               (& l:option)            local option value
;;; &g:option               (& g:option)            global option value
;;; (expr1)                 N/A                     nested expression
;;; variable                Scheme symbol           variable reference
;;; va{ria}ble              N/A [*]                 ... with curly braces
;;; $VAR                    ($ VAR)                 environment variable
;;; @r                      (@ r)                   contents of register 'r'
;;; function(expr1, ...)    (function expr1 ...)    function call
;;;                         via macros defined separately.
;;; func{ti}on(expr1, ...)  N/A [*]                 ... with curly braces
;;;
;;;                         [*] ... FIXME: Need review.
;;;
;;;                         Number, string and variable reference are handled
;;;                         by x->vim-script-notation and xire-compile .
;;;
;;;                         NB: Gauche can read "@" as a valid symbol, but
;;;                         R5RS doesn't allow such symbol.
;;;
;;; [*SPACES] It's necessary to add spaces around operators to avoid wrong
;;;     compilation result.  For example, think about compiling the following
;;;     script:
;;;
;;;         (?: 'r 's 't)
;;;
;;;     If there is wrapping spaces, resulting Vim script will be:
;;;
;;;         (r ? s : t)
;;;
;;;     If there is no wrapping spaces, resulting Vim script will be:
;;;
;;;         (r?s:t)
;;;
;;;     And the latter result is ambiguous, because "s:t" may be treated as
;;;     a script-local variable named "t" instead of local variables "s" and
;;;     "t".  There are many problems similar to this one.

(define (%compile-nary-operator-exression forms vim-script-operator context)
  `("("
    ,@(intersperse `(" " ,vim-script-operator " ")
                   (map (cut xire-compile <> context) forms))
    ")"))

(define-syntax define-nary-operator
  (syntax-rules ()
    [(_ name vim-script-operator)  ; 2 <= N
     (define-xire-expression name context
       [(valueN ..2)
        (%compile-nary-operator-exression
          valueN
          vim-script-operator
          context)])]
    [(_ name vim-script-operator initial-value)  ; 1 <= N
     (define-xire-expression name context
       [(value1)
        (xire-compile `(name initial-value ,value1) context)]
       [(valueN ..2)
        (%compile-nary-operator-exression
          valueN
          vim-script-operator
          context)])]))

(define-syntax define-binary-operator
  (syntax-rules ()
    [(_ name vim-script-operator)
     (define-xire-expression name context
       [(l r)
        (list "("
              (xire-compile l context)
              " "  ; [*SPACES] to avoid (is v e) ==> (vise)
              vim-script-operator
              " "
              (xire-compile r context)
              ")")])]))

(define-xire-expression ?: context
  [(expression then-part else-part)
   (list "("
         (xire-compile expression context)
         " ? "
         (xire-compile then-part context)
         " : "  ; [*SPACES] to avoid (?: 'r 's 't) ==> (r?s:t)
         (xire-compile else-part context)
         ")")])

(define-nary-operator or "||")

(define-nary-operator and "&&")

(define-binary-operator != "!=")
(define-binary-operator !=# "!=#")
(define-binary-operator !=? "!=?")
(define-binary-operator !~ "!~")
(define-binary-operator !~# "!~#")
(define-binary-operator !~? "!~?")
(define-binary-operator < "<")
(define-binary-operator <# "<#")
(define-binary-operator <= "<=")
(define-binary-operator <=# "<=#")
(define-binary-operator <=? "<=?")
(define-binary-operator <? "<?")
(define-binary-operator == "==")
(define-binary-operator ==# "==#")
(define-binary-operator ==? "==?")
(define-binary-operator =~ "=~")
(define-binary-operator =~# "=~#")
(define-binary-operator =~? "=~?")
(define-binary-operator > ">")
(define-binary-operator ># ">#")
(define-binary-operator >= ">=")
(define-binary-operator >=# ">=#")
(define-binary-operator >=? ">=?")
(define-binary-operator >? ">?")
(define-binary-operator is "is")
(define-binary-operator is# "is#")
(define-binary-operator is? "is?")
(define-binary-operator isnot "isnot")
(define-binary-operator isnot# "isnot#")
(define-binary-operator isnot? "isnot?")

(define-nary-operator + "+" 0)
(define-nary-operator - "-" 0)
(define-nary-operator .. ".")

(define-nary-operator * "*")
(define-nary-operator / "/")
(define-nary-operator % "%")

(define-xire-expression not context
  [(expression)
   (list "("
         "!"
         (xire-compile expression context)
         ")")])
; unary +/- operators are provided as a part of n-ary +/- operators.

(define-xire-expression ref context
  [(container-expression index-expression)
   (list "("
         "("
         (xire-compile container-expression context)
         ")"
         "["
         "("  ; To clear ambiguoussness -- a[l:r] = a[(l:r)] or a[(l):(r)]?
         (xire-compile index-expression context)
         ")"
         "]"
         ")")])
(define-xire-expression slice context
  [(container-expression index1-expression index2-expression)
   (list "("
         "("
         (xire-compile container-expression context)
         ")"
         "["
         "("
         (xire-compile index1-expression context)
         ")"
         ":"
         "("
         (xire-compile index2-expression context)
         ")"
         "]"
         ")")])
(define-xire-expression -> context
  [(dictionary (? symbol? member-name))
   (list "("
         "("
         (xire-compile dictionary context)
         ")"
         "."
         (xire-compile member-name context)
         ")")])
(define-xire-expression apply context
  [(function . arguments)
   `("("
     ,(xire-compile function context)
     "("
     ,@(intersperse "," (map (cut xire-compile <> context) arguments))
     ")"
     ")")])

(define-xire-expression list context
  [(valueN ...)
   `("["
     ,@(intersperse "," (map (cut xire-compile <> context) valueN))
     "]")])
(define-xire-expression dict context
  [(and ((key value) ...)
     (item ...))
   `("{"
     ,@(intersperse ","
                    (map (lambda (kv)
                           (list (xire-compile (car kv) context)
                                 " : "
                                 (xire-compile (cadr kv) context)))
                         item))
     "}")])
(define-xire-expression & context
  [((? symbol? option-name))
   `("&" ,(x->vim-script-notation option-name))])
(define-xire-expression $ context
  [((? symbol? variable-name))
   `("$" ,(x->vim-script-notation variable-name))])
(define-xire-expression @ context
  [((? symbol? variable-name))
   `("@" ,(x->vim-script-notation variable-name))])


;;; Control flow
;;; ------------

(define-xire-statement begin context
  ; Though there is no equivalent for BEGIN in Vim script, it's necessary to
  ; write multiple statements as a single statement in xire script.  For
  ; example: (if condition (begin statement1 statement2 ...))
  [(statement ..1)
   (map (cut xire-compile <> context) statement)])

(define-xire-statement if context
  [(condition then-part)
   (list "if"
         " "
         (xire-compile condition (make-expression-context context))
         "\n"
         (xire-compile then-part context)
         "endif"
         "\n")]
  [(condition then-part else-part)
   (list "if"
         " "
         (xire-compile condition (make-expression-context context))
         "\n"
         (xire-compile then-part context)
         "else"
         "\n"
         (xire-compile else-part context)
         "endif"
         "\n")])

(define-xire-statement while context
  [(condition statement ..1)
   (list "while"
         " "
         (xire-compile condition (make-expression-context context))
         "\n"
         (xire-compile `(begin ,@statement) context)
         "endwhile"
         "\n")])

(define-xire-statement for context
   ; :for i in list
  [((? symbol? variable) list-expression statement ..1)
   (list "for"
         " "
         (x->vim-script-notation variable)
         " "
         "in"
         " "
         (xire-compile list-expression (make-expression-context context))
         "\n"
         (xire-compile `(begin ,@statement) context)
         "endfor"
         "\n")]
  ; for [i, ...] in list-olf-lists
  [(((? symbol? variable) ..1) list-of-lists-expression statement ..1)
   (list "for"
         " "
         "["
         (intersperse "," (map x->vim-script-notation variable))
         "]"
         " "
         "in"
         " "
         (xire-compile list-of-lists-expression
                       (make-expression-context context))
         "\n"
         (xire-compile `(begin ,@statement) context)
         "endfor"
         "\n")])

(define-xire-statement break "break")

(define-xire-statement continue "continue")

(define-xire-statement return context
  [()
   '("return" "\n")]
  [(value-expression)
   (list "return"
         " "
         (xire-compile value-expression (make-expression-context context))
         "\n")])

(define-xire-statement throw context
  [(value-expression)
   (list "throw"
         " "
         (xire-compile value-expression (make-expression-context context))
         "\n")])

; FIXME: Equivalents for :try, :catch, :finally and :endtry.


;;; Equivalents for other Ex commands
;;; ---------------------------------

(define-xire-statement echo context
  [(expression ...)
   `("echo"
     " "
     ,@(intersperse " "
                    (let1 econtext (make-expression-context context)
                      (map (cut xire-compile <> econtext) expression)))
     "\n")])




;;; Main
;;; ====

(define (main args)
  ; FIXME: NIY
  0)




; __END__  {{{1
; vim: filetype=scheme foldmethod=marker
