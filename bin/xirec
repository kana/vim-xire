#!/usr/bin/env gosh
; xirec - Xire-script-to-Vim-script compiler
; Version: @@VERSION@@
; Copyright (C) 2009-2010 kana <http://whileimautomaton.net/>
; License: So-called MIT/X license  {{{
;     Permission is hereby granted, free of charge, to any person obtaining
;     a copy of this software and associated documentation files (the
;     "Software"), to deal in the Software without restriction, including
;     without limitation the rights to use, copy, modify, merge, publish,
;     distribute, sublicense, and/or sell copies of the Software, and to
;     permit persons to whom the Software is furnished to do so, subject to
;     the following conditions:
;
;     The above copyright notice and this permission notice shall be included
;     in all copies or substantial portions of the Software.
;
;     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
;     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
;     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
;     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
;     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
;     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
; }}}

(use gauche.parameter)
(use text.tree)
(use util.match)




;;; Xire context
;;; ============

;; Represent a context of xire compilation.
(define-class <xire-context> ()
  ([macros
     :init-keyword :macros
     :init-form (make-hash-table 'eq?)]))

;; Represent the current context of xire compilation.
(define xire-context
  (make-parameter (make <xire-context>)))

;; Copy the current xire context.
(define (xire-context-copy :optional (context (xire-context)))
  (make <xire-context>
        :macros (hash-table-copy (ref context 'macros))))




;;; Xire macros
;;; ===========
;;;
;;; Conventions
;;; -----------
;;;
;;; For procedures in this section,
;;;
;;; - Argument called NAME is a symbol.
;;; - Argument called EXPANDER is a procedure which takes one argument, the
;;;   form to expand.

;; Define new xire macro in the current context.
;; This is just a syntax sugar for xire-register-macro!.
(define-syntax define-xire-macro
  (syntax-rules ()
    [(_ (name form) . body)
     (xire-register-macro! 'name (lambda (form) . body))]))

;; Look up a xire macro with the NAME.
(define (xire-lookup-macro name :optional (context (xire-context)))
  (hash-table-get (ref context 'macros) name #f))

;; Register a xire macro EXPANDER with the NAME into the current CONTEXT.
(define (xire-register-macro! name expander :optional (context (xire-context)))
  (hash-table-put! (ref context 'macros) name expander))




;;; Compiler
;;; ========

;; Translate xire script into Vim script.
;; Xire script is read from INP and resulting Vim script is written into OUTP.
(define (xire-translate inp outp
                        :key (context (xire-context-copy (xire-context)))
                             (environment (make-module #f)))
  (define compiled-vim-script-tree (list))
  (define (finish)
    (write-tree (reverse compiled-vim-script-tree) outp))

  (eval '(extend user) environment)
  (parameterize ([xire-context context])
    (let loop ()
      (match (read inp)
        [(? eof-object?)
         (finish)]
        [(and ((or 'define-xire-macro)
               . _)
              form)
         (eval form environment)
         (loop)]
        [(and (name . _) form)
         (if (xire-lookup-macro name)
           (push! compiled-vim-script-tree (xire-compile form))
           (eval form environment))
         (loop)]))))

;; Compile a xire script STATEMENT, then return a resulting Vim script.
;; Resulting Vim script is expressed as a list of strings which can be passed
;; to write-tree provided by text.tree.
(define (xire-compile statement)
  ; FIXME: NIY
  )




;;; Main
;;; ====

(define (main args)
  ; FIXME: NIY
  0)




; __END__  {{{1
; vim: filetype=scheme foldmethod=marker
