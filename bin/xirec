#!/usr/bin/env gosh
; xirec - Xire-script-to-Vim-script compiler
; Version: @@VERSION@@
; Copyright (C) 2009-2010 kana <http://whileimautomaton.net/>
; License: So-called MIT/X license
;     Permission is hereby granted, free of charge, to any person obtaining
;     a copy of this software and associated documentation files (the
;     "Software"), to deal in the Software without restriction, including
;     without limitation the rights to use, copy, modify, merge, publish,
;     distribute, sublicense, and/or sell copies of the Software, and to
;     permit persons to whom the Software is furnished to do so, subject to
;     the following conditions:
;
;     The above copyright notice and this permission notice shall be included
;     in all copies or substantial portions of the Software.
;
;     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
;     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
;     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
;     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
;     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
;     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

(use gauche.parameter)
(use srfi-1)
(use text.tree)
(use util.list)
(use util.match)




;;; Environment
;;; ===========

;; Represent an environment for xire compilation.
(define-class <xire-environment> ()
  ([expression-macros  ; contain xire macro bindings for expression context.
     :init-keyword :expression-macros
     :init-form (make-hash-table 'eq?)]
   [statement-macros  ; contain xire macro bindings for statement context.
     :init-keyword :statement-macros
     :init-form (make-hash-table 'eq?)]))

;; Represent the current environment for xire compilation.
(define xire-environment
  (make-parameter (make <xire-environment>)))

;; Copy the current xire environment.
(define (xire-environment-copy :optional (environment (xire-environment)))
  (make <xire-environment>
        :expression-macros
          (hash-table-copy (ref environment 'expression-macros))
        :statement-macros
          (hash-table-copy (ref environment 'statement-macros))))




;;; Context
;;; =======

;; Represent the context to compile a xire script.  The difference between
;; <xire-context> and <xire-environment> is that:
;;
;; - <xire-environment> holds global information such as xire macro bindings.
;; - While <xire-context> holds local information, for example, whether a xire
;;   script being compiled is a top-level statement or not.
(define-class <xire-context> ()
  ([type  ; The type of a form being compiled -- statement, expression, etc.
     :init-keyword :type]
   [toplevelp  ; The flag to indicate top-level context.
     :init-keyword :toplevelp
     :init-value #f]))

(define (make-toplevel-context)
  (make <xire-context> :type :statement :toplevelp #t))
(define (make-statement-context :optional context)
  ; FIXME: Use a given CONTEXT.
  (make <xire-context> :type :statement))
(define (make-expression-context :optional context)
  ; FIXME: Use a given CONTEXT.
  (make <xire-context> :type :expression))

(define (toplevel-context? context)
  (ref context 'toplevelp))
(define (statement-context? context)
  (eq? (ref context 'type) :statement))
(define (expression-context? context)
  (eq? (ref context 'type) :expression))

(define (ensure-statement-context form context)
  (unless (statement-context? context)
    (error "Invalid form in a statement context:" form)))
(define (ensure-expression-context form context)
  (unless (expression-context? context)
    (error "Invalid form in an expression context:" form)))




;;; Xire macros
;;; ===========
;;;
;;; Conventions
;;; -----------
;;;
;;; For procedures in this section,
;;;
;;; - Argument called NAME is a symbol.
;;; - Argument called EXPANDER is a procedure which takes two arguments,
;;;   the form to expand and the context to compile the form.

(define (%context-type->slot-name context-type)
  (cond
    [(eq? context-type :expression)
     'expression-macros]
    [(eq? context-type :statement)
     'statement-macros]
    [else
      (errorf "Invalid context-type: ~s" context-type)]))

;; Look up a xire macro with the NAME from ENVIRONMENT.  The macro must be
;; available in a specified CONTEXT.
(define (xire-lookup-macro name context
                           :optional (environment (xire-environment)))
  (if (not (is-a? context <xire-context>))
    (errorf "Invalid context: ~s" context))
  (hash-table-get (ref environment
                       (%context-type->slot-name (ref context 'type)))
                  name
                  #f))

;; Register a xire macro EXPANDER with the NAME into ENVIRONMENT.  The macro
;; will be available for a specific context corresponding to CONTEXT-TYPE.
(define (xire-register-macro! name expander context-type
                              :optional (environment (xire-environment)))
  (if (not (or (eq? context-type :expression)
               (eq? context-type :statement)))
    (errorf "Invalid context-type: ~s" context-type))
  (hash-table-put! (ref environment (%context-type->slot-name context-type))
                   name
                   expander))

;; Define new xire macro in the current environment.
;; This is just a syntax sugar for xire-register-macro!.
(define-syntax define-xire-macro
  (syntax-rules ()
    [(_ context-type (name form context) . body)
     (xire-register-macro! 'name
                           (lambda (form context) . body)
                           context-type)]))

;; Define new xire statement in the current environment.
;; This is a wrapper for define-xire-macro.
(define-syntax define-xire-statement
  (syntax-rules ()
    [(_ "internal" name context [pattern . body] ...)
     (define-xire-macro :statement (name form context)
       (ensure-statement-context form context)
       (match form
         [pattern . body]
         ...))]
    ; Entry forms (sort by complexity, for proper pattern matching)
    [(_ name [pattern1 . body1] [patternN . bodyN] ...)  ; Basic form.
     (define-xire-statement name context
       [pattern1 . body1]
       [patternN . bodyN]
       ...)]
    [(_ name context [pattern1 . body1] [patternN . bodyN] ...)  ; + context.
     (define-xire-statement "internal" name context
       [pattern1 . body1]
       [patternN . bodyN]
       ...)]
    [(_ name :!)  ; Shorthand for (_ name) and (_ name!).
     (let1 name! (string->symbol (string-append (symbol->string 'name) "!"))
       (define-xire-statement name)
       (eval `(define-xire-statement ,name!)  ; FIXME: Refine.
             (current-module)))]
    [(_ name command-name)  ; For a simple statement such as :break.
     (define-xire-statement name
       [(_)
        '(command-name "\n")])]
    [(_ name)  ; Shorthand for (define-xire-statement command "command")
     (define-xire-statement name
       [(_)
        `(,(symbol->string 'name) "\n")])]
    ))

;; Define new xire expression in the current environment.
;; This is a wrapper for define-xire-macro.
(define-syntax define-xire-expression
  (syntax-rules ()
    [(_ "internal" name context [pattern . body] ...)
     (define-xire-macro :expression (name form context)
       (ensure-expression-context form context)
       (match form
         [pattern . body]
         ...))]
    ; Entry
    [(_ name [pattern . body] ...)  ; Basic form.
     (define-xire-expression name context [pattern . body] ...)]
    [(_ name context [pattern . body] ...)  ; With the name of context.
     (define-xire-expression "internal" name context [pattern . body] ...)]))




;;; Compiler
;;; ========

;; Translate xire script into Vim script.
;; Xire script is read from INP and resulting Vim script is written into OUTP.
(define (xire-translate inp outp
                        :key (environment (xire-environment-copy))
                             (scheme-environment (make-module #f)))
  (define compiled-vim-script-tree (list))
  (define (finish)
    (write-tree (reverse compiled-vim-script-tree) outp))
  (define context (make-toplevel-context))

  (eval '(extend user) scheme-environment)
  (parameterize ([xire-environment environment])
    (let loop ()
      (match (read inp)
        [(? eof-object?)
         (finish)]
        [(and ((or 'define-xire-macro)
               . _)
              form)
         (eval form scheme-environment)
         (loop)]
        [(and (name . _) form)
         (if (xire-lookup-macro name context)
           (push! compiled-vim-script-tree (xire-compile form context))
           (eval form scheme-environment))
         (loop)]))))

;; Compile a xire script FORM then return a resulting Vim script.
;; Resulting Vim script is expressed as a list of strings which can be passed
;; to write-tree provided by text.tree.
(define (xire-compile form context)
  (define (report-syntax-error)
    (errorf "Invalid xire form: ~s" form))
  (match form
    [((? symbol? name) . args)
     (cond
       [(xire-lookup-macro name context)
        => (lambda (expander)
             (xire-compile (expander form context) context))]
       [else
         (report-syntax-error)])]
    [(_ . _)  ; FORM is already compiled.
     form]
    [_
     (cond
       [(x->vim-script-notation form #f)
        => (lambda (vim-script-notation)
             (ensure-expression-context form context)
             vim-script-notation)]
       [else
         (report-syntax-error)])]))

;; Convert a given Scheme OBJECT into a string which represents
;; a corresponding Vim script object.
(define (x->vim-script-notation object :optional (raise-error-p #t))
  ; Vim script numbers are 32 bit signed integers.  (cf. :help Number)
  (define MINIMAL-NUMBER (ash -1 31))
  (define MAXIMUM-NUMBER (- (ash 1 31) 1))

  (cond
    [(number? object)
     (cond
       [(< object MINIMAL-NUMBER)
        (errorf "Too small number for Vim script: ~s" object)]
       [(< MAXIMUM-NUMBER object)
        (errorf "Too big number for Vim script: ~s" object)]
       [(integer? object)
        (number->string (inexact->exact object))]
       ; FIXME: Support float in Vim script.
       [else
        (errorf "Invalid number for Vim script: ~s" object)])]
    [(string? object)
     (string->vim-script-string-notation object)]
    [(symbol? object)  ; Vim script variable
     (convert-identifier-conventions (symbol->string object))]
    [(regexp? object)
     (regexp-replace-all* (regexp->string object)
                          #/'/ "''"
                          #/^(.*)$/ "'\\1'")]
    ; List literal is provided by a xire macro.
    ; Dictionary literal is provided by a xire macro.
    ; FIXME: How about Funcref?
    [else
      (if raise-error-p
        (errorf "Invalid object for Vim script: ~s" object)
        #f)]))

;; Convert Scheme string object into Vim script string notation.
;;
;; In xire script, Vim script strings are written as Scheme strings.  But both
;; notations are not completely equivalent.  So that we put the following
;; limitations on Scheme strings which will be compiled into Vim script:
;;
;; (i) In Scheme strings, only the following backslash-escape notations may be
;;     used:
;;
;;     \\ \" \f \n \r \t \uNNNN \xNN \<whitespace>*<newline><whitespace>*
;;
;;     - All but the last notation are the same as Vim script's ones, so that
;;       external representation of Scheme strings and Vim script strings are
;;       the same if this condition is met.  Therefore we can simply write
;;       Scheme strings as if they are Vim script strings.
;;
;;     - The last notation is processed by Scheme's reader and it is simply
;;       ignored.  So that it may be used too.
;;
;;     - Other notations (\0, \UNNNNNNNN) must not be used.  Because:
;;       - There is no equivalent for \UNNNNNNNN.  
;;       - Vim script cannot handle NUL character as is.  Though we can write
;;         "\0" in Vim script, such strings are essentially wrong.  So that it
;;         must not be used.
;;
;; (ii) The following backslash-escape notations in Vim script are not
;;      available in xire script:
;;
;;      (o) \. \.. \... (arbitrary byte, in octal digits)
;;      (x) \x.         (arbitrary byte, in single hex digit)
;;      (X) \X. \X..    (equivalent to \x. and \..)
;;      (U) \U....      (equivalent to \u....)
;;      (b) \b          (equivalent to \<BS>)
;;      (e) \e          (equivalent to \<Esc>)
;;      (k) \<Key>      (special key sequence)
;;
;;      - (o), (x) and (X): Use "\xNN" instead.
;;      - (b) and (e): Use "\xNN" instead.
;;      - (U): Incompatible with Gauche's "\UNNNNNNNN" notation and it is
;;        rarely used.
;;      - (k): Use (keyseq <Key> ...) form instead. [KEYSEQ]  FIXME: Review.
;;
;; [KEYSEQ]
;;     In Vim script, it's necessary to write special key sequences in
;;     the following situations:
;;
;;     (A) To denote input:
;;         (a) :execute 'normal!' "\<Key>"
;;         (b) :call feedkeys("\<Key>", 't')
;;         (c) :map <expr> {lhs} "\<Key>"
;;         (d) :map {lhs} <C-r>="\<Key>"<Return>
;;     (B) To compare input:
;;         (a) visualmode() ==# "\<C-v>"
;;         (b) nr2char(getchar()) =~# "[\<C-c>\<Esc>]"
;;
;;     But it's possible to write equivalent Vim script if (keyseq <Key> ...)
;;     form is available.  So that it's not a problem even if we cannot write
;;     "\<Key>" directly in xire script.
(define (string->vim-script-string-notation s)
  ; FIXME: Check the above limitations are met.
  (format "~s" s))

;; Convert identifier conventions between Scheme and Vim script.  For example,
;; Scheme usually uses hyphen (-) to join words in an identifier, while Vim
;; script uses underscore (_) for that purpose.  This procedure converts such
;; conventions.
(define (convert-identifier-conventions scheme-identifier)
  ; FIXME: Raise error for invalid characters as Vim script identifier.
  (regexp-replace-all* scheme-identifier
                       #/\?$/ "_p"
                       #/!$/ "_x"
                       #/->/ "_to_"
                       #/-/ "_"))




;;; Built-in xire macros - Primitives
;;; =================================

(define-xire-statement RAW
  ; Embed raw Vim script.  This is a temporary stuff until xire supports full
  ; features of Vim script.  Use it carefully and it should not be used if
  ; possible.
  [(_ stuffs ...)
   (map x->string stuffs)])

(define-xire-statement comment
  [(_ (? string? comment-string) ...)
   `("\""
     ,(string-join comment-string " " 'prefix)
     "\n")])




;;; Built-in xire macros - Expressions
;;; ==================================
;;;
;;; See also :help expression-syntax .
;;;
;;; [*SPACES] It's necessary to add spaces around operators to avoid wrong
;;;     compilation result.  For example, think about compiling the following
;;;     script:
;;;
;;;         (?: 'r 's 't)
;;;
;;;     If there is wrapping spaces, resulting Vim script will be:
;;;
;;;         (r ? s : t)
;;;
;;;     If there is no wrapping spaces, resulting Vim script will be:
;;;
;;;         (r?s:t)
;;;
;;;     And the latter result is ambiguous, because "s:t" may be treated as
;;;     a script-local variable named "t" instead of local variables "s" and
;;;     "t".  There are many problems similar to this one.
;;;
;;; Format:
;;; Vim script syntax       Xire script syntax      Note

;;; Utilities
;;; ---------

(define (%compile-nary-operator-exression forms vim-script-operator context)
  `("("
    ,@(intersperse `(" " ,vim-script-operator " ")
                   (map (cut xire-compile <> context) forms))
    ")"))

(define-syntax define-nary-operator
  (syntax-rules ()
    [(_ name vim-script-operator)  ; 2 <= N
     (define-xire-expression name context
       [(_ valueN ..2)
        (%compile-nary-operator-exression
          valueN
          vim-script-operator
          context)])]
    [(_ name vim-script-operator initial-value)  ; 1 <= N
     (define-xire-expression name context
       [(_ value1)
        `(name initial-value ,value1)]
       [(_ valueN ..2)
        (%compile-nary-operator-exression
          valueN
          vim-script-operator
          context)])]))

(define-syntax define-binary-operator
  (syntax-rules ()
    [(_ name vim-script-operator)
     (define-xire-expression name context
       [(_ l r)
        (list "("
              (xire-compile l context)
              " "  ; [*SPACES] to avoid (is v e) ==> (vise)
              vim-script-operator
              " "
              (xire-compile r context)
              ")")])]))


;;; expr1
;;; -----
;;;
;;; expr2 ? expr1 : expr1   (?: expr2 expr1 expr1)  if-then-else

(define-xire-expression ?: context
  [(_ expression then-part else-part)
   (list "("
         (xire-compile expression context)
         " ? "
         (xire-compile then-part context)
         " : "  ; [*SPACES] to avoid (?: 'r 's 't) ==> (r?s:t)
         (xire-compile else-part context)
         ")")])


;;; expr2
;;; -----
;;;
;;; expr3 || expr3 ...      (or expr3 ...)          logical OR

(define-nary-operator or "||")


;;; expr3
;;; -----
;;;
;;; expr4 && expr4 ...      (and expr4 ...)         logical AND

(define-nary-operator and "&&")


;;; expr4
;;; -----
;;;
;;; expr5 == expr5          (== expr5 expr5)        equal
;;; expr5 != expr5          (!= expr5 expr5)        not equal
;;; expr5 >  expr5          (>  expr5 expr5)        greater than
;;; expr5 >= expr5          (>= expr5 expr5)        greater than or equal
;;; expr5 <  expr5          (<  expr5 expr5)        smaller than
;;; expr5 <= expr5          (<= expr5 expr5)        smaller than or equal
;;; expr5 =~ expr5          (=~ expr5 expr5)        regexp matches
;;; expr5 !~ expr5          (!~ expr5 expr5)        regexp doesn't match
;;;
;;; expr5 ==? expr5         (==? expr5 expr5)       equal, ignoring case
;;; expr5 ==# expr5         (==# expr5 expr5)       equal, match case
;;; etc.                    As above, append ? for ignoring case, # for
;;;                         matching case.
;;;
;;;                         NB: Gauche can read "==#" and others as valid
;;;                         symbols, but R5RS doesn't allow to use "#" in
;;;                         symbols.
;;;
;;; expr5 is expr5          (is expr5 expr5)        same instance
;;; expr5 isnot expr5       (isnot expr5 expr5)     different instance

(define-binary-operator != "!=")
(define-binary-operator !=# "!=#")
(define-binary-operator !=? "!=?")
(define-binary-operator !~ "!~")
(define-binary-operator !~# "!~#")
(define-binary-operator !~? "!~?")
(define-binary-operator < "<")
(define-binary-operator <# "<#")
(define-binary-operator <= "<=")
(define-binary-operator <=# "<=#")
(define-binary-operator <=? "<=?")
(define-binary-operator <? "<?")
(define-binary-operator == "==")
(define-binary-operator ==# "==#")
(define-binary-operator ==? "==?")
(define-binary-operator =~ "=~")
(define-binary-operator =~# "=~#")
(define-binary-operator =~? "=~?")
(define-binary-operator > ">")
(define-binary-operator ># ">#")
(define-binary-operator >= ">=")
(define-binary-operator >=# ">=#")
(define-binary-operator >=? ">=?")
(define-binary-operator >? ">?")
(define-binary-operator is "is")
(define-binary-operator is# "is#")
(define-binary-operator is? "is?")
(define-binary-operator isnot "isnot")
(define-binary-operator isnot# "isnot#")
(define-binary-operator isnot? "isnot?")


;;; expr5
;;; -----
;;;
;;; expr6 +  expr6 ...      (+ expr6 ...)           number addition
;;;                                                 or list concatenation
;;; expr6 -  expr6 ...      (- expr6 ...)           number subtraction
;;; expr6 .  expr6 ...      (.. expr6 ...)          string concatenation
;;;                                                 (borrowed from Lua's one)
;;;
;;;                         NB: Gauche can read ".." as a valid symbol, but
;;;                         R5RS doesn't allow such symbol.

(define-nary-operator + "+" 0)
(define-nary-operator - "-" 0)
(define-nary-operator .. ".")


;;; expr6
;;; -----
;;;
;;; expr7 *  expr7 ...      (* expr7 ...)           number multiplication
;;; expr7 /  expr7 ...      (/ expr7 ...)           number division
;;; expr7 %  expr7 ...      (% expr7 ...)           number modulo

(define-nary-operator * "*")
(define-nary-operator / "/")
(define-nary-operator % "%")


;;; expr7
;;; -----
;;;
;;; ! expr7                 (! expr7)               logical NOT
;;; - expr7                 N/A                     unary minus
;;; + expr7                 N/A                     unary plus
;;;
;;;                         NB: xire provides n-ary +/- operators
;;;                         and they also serve as unary ones.

(define-xire-expression not context
  [(_ expression)
   (list "("
         "!"
         (xire-compile expression context)
         ")")])
; unary +/- operators are provided as a part of n-ary +/- operators.


;;; expr8
;;; -----
;;;
;;; expr8[expr1]            (ref expr8 expr1)       Reference an element in
;;;                                                 string, list or dictionary
;;; expr8[expr1 : expr1]    (slice expr8 expr1 expr1)
;;;                                                 Slice string or list
;;; expr8.name              (-> expr8 name)         Dictionary reference
;;; expr8(expr1, ...)       (apply expr8 expr1 ...) function call with Funcref
;;;
;;;                         NB: Gauche can read "->" as a valid symbol, but
;;;                         R5RS doesn't allow such symbol.
;;;
;;;                         FIXME: Need review - :call, call(), funcref().

(define-xire-expression ref context
  [(_ container-expression index-expression)
   (list "("
         "("
         (xire-compile container-expression context)
         ")"
         "["
         "("  ; To clear ambiguoussness -- a[l:r] = a[(l:r)] or a[(l):(r)]?
         (xire-compile index-expression context)
         ")"
         "]"
         ")")])
(define-xire-expression slice context
  [(_ container-expression index1-expression index2-expression)
   (list "("
         "("
         (xire-compile container-expression context)
         ")"
         "["
         "("
         (xire-compile index1-expression context)
         ")"
         ":"
         "("
         (xire-compile index2-expression context)
         ")"
         "]"
         ")")])
(define-xire-expression -> context
  [(_ dictionary (? symbol? member-name))
   (list "("
         "("
         (xire-compile dictionary context)
         ")"
         "."
         (xire-compile member-name context)
         ")")])
(define-xire-expression apply context
  [(_ function . arguments)
   `("("
     ,(xire-compile function context)
     "("
     ,@(intersperse "," (map (cut xire-compile <> context) arguments))
     ")"
     ")")])


;;; expr9
;;; -----
;;;
;;; number                  Scheme number           number constant
;;; "string"                Scheme string           string with \-notation
;;; 'string'                N/A                     literal string
;;; [expr1, ...]            (list expr1 ...)        list
;;; {expr1: expr1, ...}     (dict (key value) ...)  dictionary
;;; &option                 (& "option")            option value
;;; &option                 (& option)              option value
;;; &l:option               (& l:option)            local option value
;;; &g:option               (& g:option)            global option value
;;; (expr1)                 N/A                     nested expression
;;; variable                Scheme symbol           variable reference
;;; va{ria}ble              N/A [*]                 ... with curly braces
;;; $VAR                    ($ VAR)                 environment variable
;;; @r                      (@ r)                   contents of register 'r'
;;; function(expr1, ...)    (function expr1 ...)    function call
;;;                         via macros defined separately.
;;; func{ti}on(expr1, ...)  N/A [*]                 ... with curly braces
;;;
;;;                         [*] ... FIXME: Need review.
;;;
;;;                         Number, string and variable reference are handled
;;;                         by x->vim-script-notation and xire-compile .
;;;
;;;                         NB: Gauche can read "@" as a valid symbol, but
;;;                         R5RS doesn't allow such symbol.

(define-xire-expression list context
  [(_ valueN ...)
   `("["
     ,@(intersperse "," (map (cut xire-compile <> context) valueN))
     "]")])
(define-xire-expression dict context
  [(_ and ((key value) ...)
     (item ...))
   `("{"
     ,@(intersperse ","
                    (map (lambda (kv)
                           (list (xire-compile (car kv) context)
                                 " : "
                                 (xire-compile (cadr kv) context)))
                         item))
     "}")])
(define-xire-expression & context
  [(_ (? symbol? option-name))
   `("&" ,(x->vim-script-notation option-name))])
(define-xire-expression $ context
  [(_ (? symbol? variable-name))
   `("$" ,(x->vim-script-notation variable-name))])
(define-xire-expression @ context
  [(_ (? symbol? variable-name))
   `("@" ,(x->vim-script-notation variable-name))])




;;; Built-in xire macros - Control flow
;;; ===================================

(define-xire-statement begin context
  ; Though there is no equivalent for BEGIN in Vim script, it's necessary to
  ; write multiple statements as a single statement in xire script.  For
  ; example: (if condition (begin statement1 statement2 ...))
  [(_ statement ..1)
   (map (cut xire-compile <> context) statement)])

(define-xire-statement if context
  [(_ condition then-part)
   (list "if"
         " "
         (xire-compile condition (make-expression-context context))
         "\n"
         (xire-compile then-part context)
         "endif"
         "\n")]
  [(_ condition then-part else-part)
   (list "if"
         " "
         (xire-compile condition (make-expression-context context))
         "\n"
         (xire-compile then-part context)
         "else"
         "\n"
         (xire-compile else-part context)
         "endif"
         "\n")])

(define-xire-statement when context
  [(_ condition body ..1)
   `(if ,condition (begin ,@body))])
(define-xire-statement unless context
  [(_ condition body ..1)
   `(when (not ,condition) ,@body)])

(define-xire-statement while context
  [(_ condition statement ..1)
   (list "while"
         " "
         (xire-compile condition (make-expression-context context))
         "\n"
         (xire-compile `(begin ,@statement) context)
         "endwhile"
         "\n")])

(define-xire-statement for context
   ; :for i in list
  [(_ (? symbol? variable) list-expression statement ..1)
   (list "for"
         " "
         (x->vim-script-notation variable)
         " "
         "in"
         " "
         (xire-compile list-expression (make-expression-context context))
         "\n"
         (xire-compile `(begin ,@statement) context)
         "endfor"
         "\n")]
  ; for [i, ...] in list-olf-lists
  [(_ ((? symbol? variable) ..1) list-of-lists-expression statement ..1)
   (list "for"
         " "
         "["
         (intersperse "," (map x->vim-script-notation variable))
         "]"
         " "
         "in"
         " "
         (xire-compile list-of-lists-expression
                       (make-expression-context context))
         "\n"
         (xire-compile `(begin ,@statement) context)
         "endfor"
         "\n")])

(define-xire-statement break)

(define-xire-statement continue)

(define-xire-statement return context
  [(_)
   '("return" "\n")]
  [(_ value-expression)
   (list "return"
         " "
         (xire-compile value-expression (make-expression-context context))
         "\n")])

(define-xire-statement throw context
  [(_ value-expression)
   (list "throw"
         " "
         (xire-compile value-expression (make-expression-context context))
         "\n")])

; FIXME: Equivalents for :try, :catch, :finally and :endtry.




;;; Built-in xire macros - Functions
;;; ================================

(define-syntax define-xire-function
  (syntax-rules ()
    [(_ name minimum-argument-count maximum-argument-count)
     (define-xire-expression name context
       [(_ expressions ..0)
        (let1 n (length expressions)
          (if (< n minimum-argument-count)
            (errorf "Function ~s takes at least ~s arguments, but got: ~s"
                    'name
                    minimum-argument-count
                    'expressions))
          (if (and maximum-argument-count (< maximum-argument-count n))
            (errorf "Function ~s takes at most ~s arguments, but got: ~s"
                    'name
                    maximum-argument-count
                    'expressions)))
        (list "("
              'name
              "("
              (intersperse ","
                           (let1 econtext (make-expression-context context)
                             (map (cut xire-compile <> econtext) expressions)))
              ")"
              ")")])]))

(define-xire-function abs 1 1)
(define-xire-function add 2 2)
(define-xire-function append 2 2)
(define-xire-function argc 0 0)
(define-xire-function argidx 0 0)
(define-xire-function argv 0 1)
(define-xire-function atan 1 1)
(define-xire-function browse 4 4)
(define-xire-function browsedir 2 2)
(define-xire-function bufexists 1 1)
(define-xire-function buffer_exists 1 1)
(define-xire-function buffer_name 1 1)
(define-xire-function buffer_number 1 1)
(define-xire-function buflisted 1 1)
(define-xire-function bufloaded 1 1)
(define-xire-function bufname 1 1)
(define-xire-function bufnr 1 2)
(define-xire-function bufwinnr 1 1)
(define-xire-function byte2line 1 1)
(define-xire-function byteidx 2 2)
(define-xire-function call 2 3)
(define-xire-function ceil 1 1)
(define-xire-function changenr 0 0)
(define-xire-function char2nr 1 1)
(define-xire-function cindent 1 1)
(define-xire-function clearmatches 0 0)
(define-xire-function col 1 1)
(define-xire-function complete 2 2)
(define-xire-function complete_add 1 1)
(define-xire-function complete_check 0 0)
(define-xire-function confirm 1 4)
(define-xire-function copy 1 1)
(define-xire-function cos 1 1)
(define-xire-function count 2 4)
(define-xire-function cscope_connection 0 3)
(define-xire-function cursor 1 3)
(define-xire-function deepcopy 1 2)
(define-xire-function delete 1 1)
(define-xire-function did_filetype 0 0)
(define-xire-function diff_filler 1 1)
(define-xire-function diff_hlID 2 2)
(define-xire-function empty 1 1)
(define-xire-function escape 2 2)
(define-xire-function eval 1 1)
(define-xire-function eventhandler 0 0)
(define-xire-function executable 1 1)
(define-xire-function exists 1 1)
(define-xire-function expand 1 2)
(define-xire-function extend 2 3)
(define-xire-function feedkeys 1 2)
(define-xire-function file_readable 1 1)
(define-xire-function filereadable 1 1)
(define-xire-function filewritable 1 1)
(define-xire-function filter 2 2)
(define-xire-function finddir 1 3)
(define-xire-function findfile 1 3)
(define-xire-function float2nr 1 1)
(define-xire-function floor 1 1)
(define-xire-function fnameescape 1 1)
(define-xire-function fnamemodify 2 2)
(define-xire-function foldclosed 1 1)
(define-xire-function foldclosedend 1 1)
(define-xire-function foldlevel 1 1)
(define-xire-function foldtext 0 0)
(define-xire-function foldtextresult 1 1)
(define-xire-function foreground 0 0)
(define-xire-function function 1 1)
(define-xire-function garbagecollect 0 1)
(define-xire-function get 2 3)
(define-xire-function getbufline 2 3)
(define-xire-function getbufvar 2 2)
(define-xire-function getchar 0 1)
(define-xire-function getcharmod 0 0)
(define-xire-function getcmdline 0 0)
(define-xire-function getcmdpos 0 0)
(define-xire-function getcmdtype 0 0)
(define-xire-function getcwd 0 0)
(define-xire-function getfontname 0 1)
(define-xire-function getfperm 1 1)
(define-xire-function getfsize 1 1)
(define-xire-function getftime 1 1)
(define-xire-function getftype 1 1)
(define-xire-function getline 1 2)
(define-xire-function getloclist 1 1)
(define-xire-function getmatches 0 0)
(define-xire-function getpid 0 0)
(define-xire-function getpos 1 1)
(define-xire-function getqflist 0 0)
(define-xire-function getreg 0 2)
(define-xire-function getregtype 0 1)
(define-xire-function gettabvar 2 2)
(define-xire-function gettabwinvar 3 3)
(define-xire-function getwinposx 0 0)
(define-xire-function getwinposy 0 0)
(define-xire-function getwinvar 2 2)
(define-xire-function glob 1 2)
(define-xire-function globpath 2 3)
(define-xire-function has 1 1)
(define-xire-function has_key 2 2)
(define-xire-function haslocaldir 0 0)
(define-xire-function hasmapto 1 3)
(define-xire-function highlightID 1 1)
(define-xire-function highlight_exists 1 1)
(define-xire-function histadd 2 2)
(define-xire-function histdel 1 2)
(define-xire-function histget 1 2)
(define-xire-function histnr 1 1)
(define-xire-function hlID 1 1)
(define-xire-function hlexists 1 1)
(define-xire-function hostname 0 0)
(define-xire-function iconv 3 3)
(define-xire-function indent 1 1)
(define-xire-function index 2 4)
(define-xire-function input 1 3)
(define-xire-function inputdialog 1 3)
(define-xire-function inputlist 1 1)
(define-xire-function inputrestore 0 0)
(define-xire-function inputsave 0 0)
(define-xire-function inputsecret 1 2)
(define-xire-function insert 2 3)
(define-xire-function isdirectory 1 1)
(define-xire-function islocked 1 1)
(define-xire-function items 1 1)
(define-xire-function join 1 2)
(define-xire-function keys 1 1)
(define-xire-function last_buffer_nr 0 0)
(define-xire-function len 1 1)
(define-xire-function libcall 3 3)
(define-xire-function libcallnr 3 3)
(define-xire-function line 1 1)
(define-xire-function line2byte 1 1)
(define-xire-function lispindent 1 1)
(define-xire-function localtime 0 0)
(define-xire-function log10 1 1)
(define-xire-function map 2 2)
(define-xire-function maparg 1 3)
(define-xire-function mapcheck 1 3)
(define-xire-function match 2 4)
(define-xire-function matchadd 2 4)
(define-xire-function matcharg 1 1)
(define-xire-function matchdelete 1 1)
(define-xire-function matchend 2 4)
(define-xire-function matchlist 2 4)
(define-xire-function matchstr 2 4)
(define-xire-function max 1 1)
(define-xire-function migemo 1 1)
(define-xire-function min 1 1)
(define-xire-function mkdir 1 3)
(define-xire-function mode 0 1)
(define-xire-function nextnonblank 1 1)
(define-xire-function nr2char 1 1)
(define-xire-function pathshorten 1 1)
(define-xire-function pow 2 2)
(define-xire-function prevnonblank 1 1)
(define-xire-function printf 2 #f)
(define-xire-function pumvisible 0 0)
(define-xire-function range 1 3)
(define-xire-function readfile 1 3)
(define-xire-function reltime 0 2)
(define-xire-function reltimestr 1 1)
(define-xire-function remote_expr 2 3)
(define-xire-function remote_foreground 1 1)
(define-xire-function remote_peek 1 2)
(define-xire-function remote_read 1 1)
(define-xire-function remote_send 2 3)
(define-xire-function remove 2 3)
(define-xire-function rename 2 2)
(define-xire-function repeat 2 2)
(define-xire-function resolve 1 1)
(define-xire-function reverse 1 1)
(define-xire-function round 1 1)
(define-xire-function search 1 4)
(define-xire-function searchdecl 1 3)
(define-xire-function searchpair 3 7)
(define-xire-function searchpairpos 3 7)
(define-xire-function searchpos 1 4)
(define-xire-function server2client 2 2)
(define-xire-function serverlist 0 0)
(define-xire-function setbufvar 3 3)
(define-xire-function setcmdpos 1 1)
(define-xire-function setline 2 2)
(define-xire-function setloclist 2 3)
(define-xire-function setmatches 1 1)
(define-xire-function setpos 2 2)
(define-xire-function setqflist 1 2)
(define-xire-function setreg 2 3)
(define-xire-function settabvar 3 3)
(define-xire-function settabwinvar 4 4)
(define-xire-function setwinvar 3 3)
(define-xire-function shellescape 1 2)
(define-xire-function simplify 1 1)
(define-xire-function sin 1 1)
(define-xire-function sort 1 2)
(define-xire-function soundfold 1 1)
(define-xire-function spellbadword 0 1)
(define-xire-function spellsuggest 1 3)
(define-xire-function split 1 3)
(define-xire-function sqrt 1 1)
(define-xire-function str2float 1 1)
(define-xire-function str2nr 1 2)
(define-xire-function strftime 1 2)
(define-xire-function stridx 2 3)
(define-xire-function string 1 1)
(define-xire-function strlen 1 1)
(define-xire-function strpart 2 3)
(define-xire-function strridx 2 3)
(define-xire-function strtrans 1 1)
(define-xire-function submatch 1 1)
(define-xire-function substitute 4 4)
(define-xire-function synID 3 3)
(define-xire-function synIDattr 2 3)
(define-xire-function synIDtrans 1 1)
(define-xire-function synstack 2 2)
(define-xire-function system 1 2)
(define-xire-function tabpagebuflist 0 1)
(define-xire-function tabpagenr 0 1)
(define-xire-function tabpagewinnr 1 2)
(define-xire-function tagfiles 0 0)
(define-xire-function taglist 1 1)
(define-xire-function tempname 0 0)
(define-xire-function test 1 1)
(define-xire-function tolower 1 1)
(define-xire-function toupper 1 1)
(define-xire-function tr 3 3)
(define-xire-function trunc 1 1)
(define-xire-function type 1 1)
(define-xire-function values 1 1)
(define-xire-function virtcol 1 1)
(define-xire-function visualmode 0 1)
(define-xire-function winbufnr 1 1)
(define-xire-function wincol 0 0)
(define-xire-function winheight 1 1)
(define-xire-function winline 0 0)
(define-xire-function winnr 0 1)
(define-xire-function winrestcmd 0 0)
(define-xire-function winrestview 1 1)
(define-xire-function winsaveview 0 0)
(define-xire-function winwidth 1 1)
(define-xire-function writefile 2 3)




;;; Built-in xire macros - Ex commands (except control flow)
;;; ========================================================
;;;
;;; Definitions are sorted in alphabetical order.

;;; Common utilities
;;; ----------------

;; Define an Ex command modifier such as :vertical.
;;
;; [*] Consider the following statements.  It's not easy to compile:
;;
;;     (define-xire-statement-modifier aboveleft)
;;     (define-xire-statement-modifier belowright)
;;     (define-xire-statement-modifier vertical)
;;
;;     (aboveleft
;;       (new)
;;       (vertical
;;         (new)
;;         (belowright
;;           (new))))
;;     (vertical
;;       (begin
;;         (new)
;;         (new)))
(define-syntax define-xire-statement-modifier
  (syntax-rules ()
    [(_ name)
     (define-xire-statement-modifier name (symbol->string 'name))]
    [(_ name vim-command-name)
     (define-xire-statement name context
       [(_ body)  ; FIXME: Support multiple statements.  [*]
        `(,vim-command-name " " ,(xire-compile body context))])]))

;; Escape a given PATH with `={expr}` notation to avoid special meaning of
;; metacharacters in arguments for :edit-like Ex commands.
(define (escape-path path)
  `("`='" ,(regexp-replace-all* path #/'/ "''") "'`"))

;; Parse OPTIONS which expresses a list of ++opt.
;;
;; Examples:
;;   :edit ++{option} ==> (edit :{option} #t)
;;   :edit ++{option}={value} ==> (edit :{option} {value})
(define (parse-++opt options)
  (let-keywords options ([bad #f]
                         [binary #f]
                         [edit #f]
                         [encoding #f]
                         [fileformat #f]
                         [nobinary #f]
                         . etc)
    (define (_ name value)
      (cond
        [(string? value) (list "++" name "=" value)]
        [value (list "++" name)]
        [else #f]))
    (if (not (null? etc))
      (errorf "Invalid options: ~s" etc))
    (remove (lambda (x) (eq? x #f))
            (list (_ "bad" bad)
                  (_ "binary" binary)
                  (_ "edit" edit)
                  (_ "encoding" encoding)
                  (_ "fileformat" fileformat)
                  (_ "nobinary" nobinary)))))


;;; Commands - A
;;; ------------

(define-xire-statement-modifier aboveleft)
(define-xire-statement ascii)


;;; Commands - B
;;; ------------

(define-xire-statement-modifier belowright)
(define-xire-statement-modifier botright)
(define-xire-statement-modifier browse)
(define-xire-statement buffers :!)


;;; Commands - C
;;; ------------

(define-xire-statement changes)
(define-xire-statement checkpath :!)
(define-xire-statement close :!)
(define-xire-statement comclear)
(define-xire-statement-modifier confirm)
(define-xire-statement cquit :!)


;;; Commands - D
;;; ------------

(define-xire-statement diffoff :!)
(define-xire-statement diffthis)
(define-xire-statement diffupdate)


;;; Commands - E
;;; ------------

(define-xire-statement echo context
  [(_ expression ...)
   `("echo"
     " "
     ,@(intersperse " "
                    (let1 econtext (make-expression-context context)
                      (map (cut xire-compile <> econtext) expression)))
     "\n")])

(define-xire-statement %edit context
  ; +cmd is not supported.  Because:
  ;
  ; - It's not useful for scripting use.
  ; - It's possible to write equivalent script easily.
  ;   For example, ":edit +3 foo" can be written as ":edit foo | 3".
  ; - And the latter style is more readable than the former style.
  [(_ :internal command-name bang path . options)
   (list command-name bang
         (map (cut cons " " <>)
              (parse-++opt options))
         (if path
           (list " " path)
           "")
         "\n")]
  ; Entry
  [; :edit {path}
   (_ command-name bang (? string? path) . options)
   `(%edit :internal
           ,command-name
           ,bang
           ,(escape-path path)
           ,@options)]
  [; :edit #
   (_ command-name bang :alternate . options)
   `(%edit :internal ,command-name ,bang "#" ,@options)]
  [; :edit #[count]
   (_ command-name bang :buffer (? integer? number) . options)
   `(%edit :internal ,command-name ,bang ("#" ,number) ,@options)]
  [; :edit `command`
   (_ command-name bang :command command . options)
   `(%edit :internal
           ,command-name
           ,bang
           ("`" ,(regexp-replace-all* command #/\\/ "\\\\\\\\") "`")
           ,@options)]
  [; :edit `=expression`
   (_ command-name bang :expression expression . options)
   `(%edit :internal
           ,command-name
           ,bang
           ("`="
            ,(xire-compile expression (make-expression-context context))
            "`")
           ,@options)]
  [; :edit
   (_ command-name bang . options)
   `(%edit :internal ,command-name ,bang #f ,@options)])

(define-xire-statement edit context
  [(_ . arguments)
   `(%edit "edit" "" ,@arguments)])
(define-xire-statement edit! context
  [(_ . arguments)
   `(%edit "edit" "!" ,@arguments)])

(define-xire-statement enew)
(define-xire-statement enew!)

(define-xire-statement ex context
  [(_ . arguments)
   `(%edit "ex" "" ,@arguments)])
(define-xire-statement ex! context
  [(_ . arguments)
   `(%edit "ex" "!" ,@arguments)])

(define-xire-statement exusage)


;;; Commands - F
;;; ------------

(define-xire-statement %file context
  [(_ bang)
   `("file" ,bang "\n")]
  [(_ bang #f)
   `("0" "file" ,bang "\n")]
  [(_ bang path)
   `("file" ,bang " " ,(escape-path path) "\n")])
(define-xire-statement file context
  [(_ . arguments)
   `(%file "" ,@arguments)])
(define-xire-statement file! context
  [(_ . arguments)
   `(%file "!" ,@arguments)])

(define-xire-statement files :!)

(define-xire-statement find context
  ; FIXME: Support count.
  [(_ . arguments)
   `(%edit "find" "" ,@arguments)])
(define-xire-statement find! context
  ; FIXME: Support count.
  [(_ . arguments)
   `(%edit "find" "!" ,@arguments)])

(define-xire-statement finish)
(define-xire-statement fixdel)


;;; Commands - H
;;; ------------

(define-xire-statement-modifier hide)


;;; Commands - I
;;; ------------

(define-xire-statement intro)


;;; Commands - J
;;; ------------

(define-xire-statement jumps)


;;; Commands - K
;;; ------------

(define-xire-statement-modifier keepalt)
(define-xire-statement-modifier keepjumps)
(define-xire-statement-modifier keepmarks)


;;; Commands - L
;;; ------------

(define-xire-statement-modifier leftabove)
(define-xire-statement loadkeymap)
(define-xire-statement-modifier lockmarks)
(define-xire-statement ls :!)


;;; Commands - M
;;; ------------

(define-xire-statement messages)


;;; Commands - N
;;; ------------

(define-xire-statement-modifier noautocmd)
(define-xire-statement nohlsearch)


;;; Commands - O
;;; ------------

(define-xire-statement oldfiles :!)
(define-xire-statement only :!)
(define-xire-statement options)


;;; Commands - P
;;; ------------

(define-xire-statement pclose :!)
(define-xire-statement preserve)
(define-xire-statement ptlast :!)
(define-xire-statement pwd)


;;; Commands - Q
;;; ------------

(define-xire-statement qall :!)
(define-xire-statement quit :!)
(define-xire-statement quitall :!)


;;; Commands - R
;;; ------------

(define-xire-statement redo)
(define-xire-statement redraw :!)
(define-xire-statement redrawstatus :!)
(define-xire-statement-modifier rightbelow)


;;; Commands - S
;;; ------------

(define-xire-statement-modifier sandbox)
(define-xire-statement sbfirst)
(define-xire-statement sblast)
(define-xire-statement sbrewind)
(define-xire-statement scriptnames)
(define-xire-statement shell)
(define-xire-statement-modifier silent)
(define-xire-statement spelldump :!)
(define-xire-statement spellinfo)
(define-xire-statement spellrepall)
(define-xire-statement startgreplace :!)
(define-xire-statement startinsert :!)
(define-xire-statement startreplace :!)
(define-xire-statement stop :!)
(define-xire-statement stopinsert :!)
(define-xire-statement suspend :!)
(define-xire-statement swapname)
(define-xire-statement syncbind)


;;; Commands - T
;;; ------------

(define-xire-statement-modifier tab)
(define-xire-statement tabfirst)
(define-xire-statement tablast)
(define-xire-statement tabonly :!)
(define-xire-statement tabrewind)
(define-xire-statement tabs)
(define-xire-statement tags)
(define-xire-statement tlast :!)
(define-xire-statement-modifier topleft)


;;; Commands - U
;;; ------------

(define-xire-statement undojoin)
(define-xire-statement undolist)
(define-xire-statement-modifier unsilent)


;;; Commands - V
;;; ------------

(define-xire-statement-modifier verbose)
(define-xire-statement-modifier vertical)

(define-xire-statement view context
  [(_ . arguments)
   `(%edit "view" "" ,@arguments)])
(define-xire-statement view! context
  [(_ . arguments)
   `(%edit "view" "!" ,@arguments)])

(define-xire-statement visual context
  [(_ . arguments)
   `(%edit "visual" "" ,@arguments)])
(define-xire-statement visual! context
  [(_ . arguments)
   `(%edit "visual" "!" ,@arguments)])

(define-xire-statement viusage)


;;; Commands - W
;;; ------------

(define-xire-statement wall :!)


;;; Commands - X
;;; ------------

(define-xire-statement X)
(define-xire-statement xall :!)




;;; Main
;;; ====

(define (main args)
  ; FIXME: NIY
  0)




; __END__
; =======
; vim: filetype=scheme foldmethod=expr
; vim: foldexpr=getline(v\:lnum-1)==''&&getline(v\:lnum+1)=~'[-=]\\{4,}$'?'>'.stridx('X=-',getline(v\:lnum+1)[-1\:])\:'='
