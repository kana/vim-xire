xire -- Turn Vim script into a programmable programming language
================================================================
Kana Natsuno <kana@whileimautomaton.n3t>
:toc:





Introduction
------------

Xire is a tool to compile a domain-specific language into Vim script,
and xire is also the name of the DSL itself.  The DSL is based on Scheme
which is a dialect of Lisp.  Xire turns Vim script into a programmable
programming language.

One might wonder about reasons to use xire.  There are the following
problems about Vim script:

- Vim script is weak.  Because it is not designed as a programming
  language at the first.  Vim script is just a series of Ex commands,
  and its syntax is too arbitrary as a programming language.  Vim script
  is nearly impossible to extend the language itself, because the ways
  to abstract details are limited.
- There are several interfaces to other languages.  For example, Vim
  version 7.3 provides interfaces to Lua, Perl, Python, Ruby, Scheme and
  Tcl.  But the foreign language interfaces are not portable and they
  are not seamlessly integrated with Vim.

And all of the above problems can be resolved with xire.




Requirements
~~~~~~~~~~~~

- http://www.vim.org/[Vim] version 7.3 or later
- http://practical-scheme.net/gauche/[Gauche] version 0.9 or later




Links
~~~~~

- http://github.com/kana/vim-xire[Public source code repository]





External Commands
-----------------

xirec
~~~~~

A compiler that compile a xire script into Vim script.  It reads a xire
script from the standard input, then it writes the resulting Vim script
to the standard output.

.Typical Usage
----
$ xirec <foo.xire >foo.vim
----





Xire Script
-----------

Abstract
~~~~~~~~

Xire script is a Scheme-based DSL to write Vim script.  Xire script
consists of a series of xire expressions.  Xire expressions are
evaluated sequentially from first to last.

Each xire expression is a list of S expressions.  The first value of the
list is used to determine the type of the expression.  Each xire
expression can be classified into one of the following categories:

Directives::
    Directives control the current compiling process.  For example,
    a directive defines a new macro, while another directive Scheme
    environment to compile the current script.

Macros::
    Macros are corresponding to pieces of Vim script.  There are two
    types of statements.  One is a *statement macro* which is expanded
    into a series of Ex commands, and the other is an *expression macro*
    which is expanded into an expression of Vim script.  Macros can be
    nested.  Such macros are recursively expanded.




Process of Macro Expansion
~~~~~~~~~~~~~~~~~~~~~~~~~~

Suppose that there is a following expression macro `foo`:

----
(define-xire-expr foo
  [pattern1 body1 ...]
  [pattern2 body2 ...]
  ...)
----

The process to expand a use of an expression macro `(foo bar baz)` is
roughly equivalent to the following code:

----
(use util.match)
(match '(bar baz)
  [pattern1 body1 ...]
  [pattern2 body2 ...]
  ...)
----

This process is also used to expand a use of statement macros.




Intermediate Format
~~~~~~~~~~~~~~~~~~~

Xire macros are finally expanded into corresponding code in Vim script.
However, results of macro expansion are accumulated and resulting Vim
script is not generated until the whole of a xire script is processed.

Results of macro expansion must be the intermediate format of Vim
script.  The details of the intermediate format are as follows:

`<boolean>` objects::
    Compiled into a corresponding boolean value in Vim script.

`<number>` objects::
    Compiled into a corresponding number value in Vim script.  Only
    exact integers are valid.  It is an error to use inexact numbers and
    non-integer numbers such as real numbers, though real numbers should
    be supported later.  Note that numbers in Vim script are limited in
    a range, and the range depends on how Vim executable is compiled.
    So that xire does not check whether a given number is also valid as
    Vim script or not.

`<regexp>` objects::
    Compiled into a corresponding string value in Vim script (because
    there is no literal notation for regular expressions in Vim script).

`<string>` objects::
    Compiled into a corresponding string value in Vim script.  See also
    <<_conventions_of_string_values, conventions of string values>>.

`<symbol>` objects::
    The names of symbols are normalized, then
    <<_normalization_of_variable_names,normalized names>> are embedded
    into resulting Vim script.

`(macro-name . args)`::
    `macro-name` is an arbitrary symbol and `args` is a list of
    arbitrary values.  If a xire macro which name is equal to
    `macro-name` is defined, the macro is expanded with `args`.
    Otherwise, it is an error.

`(x . xs)`::
    `x` is an arbitrary value except symbols.  This form is to embed
    arbitrary values into resulting Vim script.  Each value in this form
    is embedded with
    http://practical-scheme.net/gauche/man/?l=en&p=display[`display`],
    from left to right.



==== Conventions of String Values

The syntax of string literals is different between Scheme and Vim
script.  So that there are the following limitations on Scheme strings
which are compiled into Vim script:


===== Available Backslash-Escape Notations in Scheme Strings

In Scheme strings, only the following backslash-escape notations may be
used:

- `\\`
- `\"`
- `\f`
- `\n`
- `\r`
- `\t`
- `\uNNNN`
- `\xNN`
- `\<whitespace>*<newline><whitespace>*`

All but the last notation are also available in Vim script.  The last
notation is not available in Vim script, but it is processed and simply
discarded by ++read++er of Scheme.

So that external representation of Scheme strings and ones of Vim script
strings are the same if the above condition is met.  Therefore it's
possible to write Scheme strings as if they are Vim script strings.

Other notations (`\0` and `\UNNNNNNNN`) must not be used.  Because:

- There is no equivalent for `\UNNNNNNNN` in Vim script.
- Vim script cannot handle NUL character as is.  Though we can write
  `"\0"` in Vim script, such strings are essentially wrong.  So that it
  must not be used.


===== Unavailable Backslash-Escape Notations in Vim script Strings

The following backslash-escape notations in Vim script are not available
in xire script:

[options='header']
|===================================================================
|Label  |Notations              |Meaning
|(o)    |`\.`, `\..`, `\...`	|Arbitrary byte, in octal digits
|(x)    |`\x.`                  |Arbitrary byte, in single hex digit
|(X)    |`\X.`, `\X..`          |Equivalent to `\x.` and `\x..`
|(U)    |`\U....`               |Equivalent to `\u....`
|(b)    |`\b`                   |Equivalent to `\<BS>`
|(e)    |`\e`                   |Equivalent to `\<Esc>`
|(k)    |`\<Key>`               |Special key sequence
|===================================================================

- (o), (x) and (X): Use `"\xNN"` instead.
- (b) and (e): Use `"\xNN"` instead.
- (U): Incompatible with `"\UNNNNNNNN"` notation in Gauche strings and
  it is rarely used.
- (k): Use +(<<_kbd,kbd>> "<Key> ...")+ form instead.



==== Normalization of Variable Names

While various characters such as `$`, `!` and `%` can be used as
variable names in Scheme, variable names in Vim script must match to
`#/^[A-Za-z_][A-Za-z_0-9]*$/`.  So that it is generally an error to use
such characters for symbols in the <<_intermediate_format,intermediate
format>>.

But, for convenience, several characters (more precisely, patterns) can
be used for symbols in the intermediate format.

[options='header']
|==================================================================
|Pattern        |Replacement    |Example Symbol |Replacement Result
|`#/\?$/`       |`_p`           |`eq?`          |`eq_p`
|`#/!$/`        |`_x`           |`set!`         |`set_x`
|`#/->/`        |`_to_`         |`vector->list` |`vector_to_list`
|`#/[-%]/`      |`_`            |`read-char`    |`read_char`
|==================================================================




Directives
~~~~~~~~~~

==== `(define-xire-expr [context] name clause ...)`

`define-xire-expr` directive defines a new expression macro.

`context` (arbitrary symbol)::
    Specifies the name of a variable which is bound to the current
    context of a macro expansion.  This variable is available in
    ++body++s of each `clause`.  It may be omitted if `context` is
     not used in each `clause`.

`name` (arbitrary symbol)::
    Specifies the name of the new macro.

`clause` (`[pattern body ...]` or `[pattern (=> identifier) body ...]`)::
    Specifies an expansion rule for the new macro.  The format of
    `clause` is the same as
    http://practical-scheme.net/gauche/man/?l=en&p=match[`match`].

See also <<_process_of_macro_expansion,Process of Macro Expansion>>.



==== `(define-xire-stmt [context] name clause ...)`

`define-xire-stmt` directive defines a new statement macro.

`context` (arbitrary symbol)::
    Specifies the name of a variable which is bound to the current
    context of a macro expansion.  This variable is available in
    ++body++s of each `clause`.  It may be omitted if `context` is
     not used in each `clause`.

`name` (arbitrary symbol)::
    Specifies the name of the new macro.

`clause` (`[pattern body ...]` or `[pattern (=> identifier) body ...]`)::
    Specifies an expansion rule for the new macro.  The format of
    `clause` is the same as
    http://practical-scheme.net/gauche/man/?l=en&p=match[`match`].

See also <<_process_of_macro_expansion,Process of Macro Expansion>>.

There are also the following shorthands for `define-xire-stmt`:

`(define-xire-stmt <name>)`::
    Roughly equivalent to the following:

    (define-xire-stmt <name> "<name>")

`(define-xire-stmt <name> :!)`::
    Roughly equivalent to the following:

    (define-xire-stmt <name> "<name>")
    (define-xire-stmt <name> "<name>!")

`(define-xire-stmt <name> <ex-command-name>)`::
    Roughly equivalent to the following:

    (define-xire-stmt <name>
      [(_)
       '(<ex-command-name>)])  ; <ex-command-name> must be a string.



==== `(scheme scheme-expression ...)`

`scheme` directive evaluates arbitrary ++scheme-expression++s as if
`(begin scheme-expression ...)`.




Macros
~~~~~~

FIXME: Write about details of macros.





License
-------

So-called MIT/X license.

Copyright (C) 2009-2011 Kana Natsuno <kana@whileimautomaton.n3t>

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.





// vim: filetype=asciidoc
// vim: textwidth=72 expandtab softtabstop=4 shiftwidth=4
